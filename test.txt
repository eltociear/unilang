"#", "(C) 2021-2022 Uniontech Software Technology Co.,Ltd.",
"Unilang test script.";

$import! std.math &=? &<? &<=? &>? &>=? &stoi &itos;

$def! $rem $vau . #ignore "";

info "sanity";
subinfo "empty expression";
$expect ();
subinfo "zeros";
$expect 0 0;
$expect 0 +0;
$expect 0 -0;
$expect 0 00;
$expect 0.0 0.0;
$expect 0.0 +0.0;
$expect 0.0 0.00;
$expect 0.0 00.0;
$expect -0.0 -0.0;
subinfo "id expressions";
$expect 42 $let ((a 42)) a;
$expect 42 $let (('' 42)) '';
$expect 42 $let ((' ' 42)) ' ';

info "function calls";
() $let ()
(
	subinfo "basic combiner calls";
	$defl! g fm apply - fm;
	$defv! $g fm #ignore eval (list* - fm) (() get-current-environment);
	$expect (- 0 1) g 2 3;
	$expect (- 0 1) $g 3 4;
	subinfo "combiner rvalue calls";
	$expect () ($lambda (x) forward! x) ();
	$expect () ($lambda (x) ($lambda (y) idv y) x) ();
	$expect () ($lambda (x) ($lambda (y) id y) x) ();
	$expect "" ($lambda (x) ($lambda (y) ++ y) x) "";
	$expect () ($lambda (x) ($lambda (y)) x) ();
	$expect () ($lambda (x) ($lambda (.)) x) ();
	$expect () ($lambda (x) ($lambda (.) ()) x) ();
	$expect () ($lambda (x) ($lambda (y) y) x) ();
	$expect () ($lambda (x) ($lambda (y) (idv y)) x) ();
	$expect ()
		($def! foo $lambda (z) z; ($lambda (x) ($lambda (y) foo y) x) ());
	$expect () ($lambda (x) ($lambda (y) ($lambda (z) z) y) x) ();
	$expect () ($def! l list (); ($lambda ((&x .)) x) l)
);

info "recursive function calls";
$let ()
(
	subinfo "Fibonacci";
	$defl! fib (&n) $if (<=? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)));
	$expect 8 fib 5;
	subinfo "Hofstadter Female and Male sequences";
	$def! (F M) (list ($lambda (&n) $if (eqv? n 0) 1 (- n (M (F (- n 1)))))
		($lambda (&n) $if (eqv? n 0) 0 (- n (F (M (- n 1))))));
	$expect 5 F 7;
	$expect 4 M 7
);

info "basic object operations";
$let ()
(
	$def! fwd? $vau% (&x) d
		($lambda% (%v) bound-lvalue? ($resolve-identifier v)) (eval% x d);
	$expect (list% #f #f #t #t #f)
		list% (fwd? 1) (fwd? ()) (fwd? fwd?) (fwd? (id fwd?))
			(fwd? (idv fwd?));
);

info "reference, reference collapsing and reference assignment";
$let ()
(
	$def! (a b) list 1 2;
	$def! li list% a 2;
	$def! lie list% (expire a) 2;
	$def! li2 list% 3 4;
	subinfo "expecting different results for 'first&' and 'first@'";
	$expect #f eq? (first& li) (first@ li);
	subinfo "collapsing test";
	$expect #t reference? (first@ li);
	$expect #t uncollapsed? (first@ li);
	$expect #t reference? (idv (first@ li));
	$expect #f uncollapsed? (idv (first@ li));
	$expect #f unique? (collapse (expire (first@ li)));
	$expect #t unique? (collapse (expire (first@ lie)));
	$expect #f unique? (collapse (first@ li));
	subinfo "the collapsed value category";
	$expect #f unique? (collapse (first@ lie));
	subinfo "expecting prvalue for reference to reference";
	$expect 1 idv (idv (first@ li));
	$expect 1 idv (idv ((wrap ($vau% (%x) #ignore x)) (first@ li)));
	$expect 1 idv (idv (($lambda% (%x) x) (first@ li)));
	subinfo "id and reference tests";
	$def! a 1;
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #f eqv? (id b) 1;
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t reference? (id b);
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t uncollapsed? (id b);
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t eqv? (idv (idv (id b))) 1;
	subinfo "idv move! tests";
	$expect #t eqv? (idv (move! 42)) 42;
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t eqv? (idv (move! b)) 1;
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #f reference? (idv (move! b));
	subinfo "move! tests";
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t eqv? (move! b) 1;
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #t reference? (move! b);
	$def! b 2;
	$def! li list% a 2;
	assign@! b (first@ li);
	$expect #f uncollapsed? (move! b);
	subinfo "preventing non-first-class temporary objects";
	$let ()
	(
		$defl! test-nt (&f)
			$let ((&t (idv unit)) (&u (idv unit)) (&v (idv unit)))
			(
				$def! x f t;
				forward! x;
				$expect unit x;
				assign@! x (f u);
				forward! x;
				$expect unit x;
				assign%! x (f v);
				forward! x;
				$expect unit x
			);
		test-nt move!;
		test-nt forward!
	)
);

info "combiner operations";
subinfo "combiner equality";
$let ()
(
	$check eqv? (idv idv) idv;
	$check not? (eqv? (wrap idv) idv);
	$check eqv? (wrap idv) (wrap idv);
	$check eqv? (unwrap unwrap) (unwrap unwrap);
	$def! $quote $vau% (x) #ignore $move-resolved! x;
	$def! idv wrap $quote;
	$check eqv? (unwrap idv) $quote;
	$check eqv? (unwrap (idv idv)) $quote;
	$check eqv? (unwrap idv) (unwrap (idv idv));
	$check eqv? (wrap (unwrap idv)) idv;
);

info "logical operations";
$let ()
(
	subinfo "logical not";
	$expect #t eqv? ($let ((f #f)) not? f) (not? #f);
	subinfo "non-strict logical operations";
	$expect #t () $and;
	$expect #f () $or;
	$expect #f $and #f #f;
	$expect #t $or #f #t;
	$expect 2 $and 1 2;
	$expect 1 $or 1 #f;
	$expect 2 $or #f 2 #f 3
);

info "list operations";
$let ()
(
	$expect () list* ();
	$expect () list*% ();
	$def! n 1;
	$let ((a list 2 3))
	(
		subinfo "list lvalue elements accesses";
		$expect 2 first (id a);
		$expect 2 first a;
		$check reference? (first a);
		$check reference? (first% (list% n 2));
		subinfo "list xvalue elements accesses";
		$expect 2 first (as-const (expire a));
		$expect 2 first (expire a);
		$expect-moved first a
	);
	subinfo "first forwarding";
	$let ()
	(
		$defl! test (f)
		(
			$def! li list% (expire (as-const n)) 2;
			$check not? (modifiable? (f li));
			$check unique? (f li);
			$expect 1 f li
		);
		test first
	)
);

info "local bindings";
() $let ()
(
	$expect () $let ();
	$expect 5 $let ((&x 2) (&y 3)) + x y;
	$expect 4 $let* ((&x 2) (&y x)) + x y;
	$expect 3 $letrec ((x + 0 1) (x 2) (x - 4 1)) x;
	$expect (list 1 2 3) $letrec ((x + 0 1) (y 2) (z - 4 1)) list x y z
);

info "Documented examples.";
$let ()
(
	display "Hello, world!";
	display (display "Hello, world!");
	(display "Hello, world!");
	() newline;
	() display "Hello, world!";
	display "Hello, world!";
	$sequence display "Hello, world!";
	display "Hello, "; display "world!";
	$sequence (display "Hello, ") (display "world!");
	$def! x "hello";
	list "hello" "world";
	cons "x" ();
	list "x";
	cons "x" (cons "y" ());
	list "x" "y";
	$lambda (x) display x;
	$lambda (x) x;
	($lambda (x) display x);
	($lambda (x) (display x));
	$lambda (x y) $sequence (display x) (display y);
	$def! id $lambda (x) x;
	display (($lambda ((x y)) x) (list "hello" "world"));
	$def! car $lambda ((x .)) x; $def! cdr $lambda ((#ignore .x)) x;
	eval (list display "Hello, world!") (() get-current-environment);
	$def! (x y) list "hello" "world"; display x; display y;
	$def! id $lambda (x) x;
	$defl! id (x) x;
	$def! x (); display "x is "; display ($if (null? x) "empty" "not empty")
);

info "Test case on parent environment search.";
$let ()
(
	$def! e make-environment (() get-current-environment);
	eval ((unwrap ($lambda (x) x)) e) e
);

info "make-encapsulation-type";
subinfo "encapsulation values";
$let ()
(
	$def! (e p? d) () make-encapsulation-type;
	p? 1;
	$def! enc e 1;
	$expect #t p? enc;
	$expect #f p? "str";
	$expect 1 d enc;
	$expect 2 d (e 2);
	$expect #t eqv? (e (list 1 2)) (e (list 1 2));
	$expect #f eqv? (e (list 1 2)) (e (list 3 4))
);
subinfo "encapsulation temporary values";
$let ((u unit) (&lt unit) (&t (idv unit)))
(
	$def! (e% #ignore d) () make-encapsulation-type;
	$def! o e% u;
	forward! (d o);
	$expect unit d o;
	$def! o e% lt;
	forward! (d o);
	$expect unit d o;
	$def! o e% t;
	forward! (d o);
	$expect-moved d o
);
subinfo "encapsulation equality";
$let ()
(
	$def! (e #ignore d) () make-encapsulation-type;
	$def! x e 1;
	$def! y e 2;
	$def! z e 2;
	$expect #f eqv? x y;
	$expect #t eqv? y z
);

info "std.promises tests";
$let ()
(
	$import! std.promises
		promise? memoize $lazy $lazy% $lazy/d $lazy/d% force;
	subinfo "value category preservation";
	$let ((p1 $lazy% idv unit))
	(
		$expect unit force unit;
		$expect unit force ($lazy p1);
		force (expire p1);
		$expect-moved force ($lazy p1)
	);
	subinfo "force idempotence";
	$let ((a unit))
	(
		$def! p $lazy a;
		$expect (force p) force p;
	);
	subinfo "lifting safety";
	$let ()
	(
		$defl! me ()
		(
			$def! e () make-environment;
			$set! e x 42;
			e
		);
		$expect 42 force ($lazy/d (() me) x);
		$expect 42 force ($lazy% $lazy/d (() me) x);
		$expect 42 force ($lazy $lazy/d% (() me) x)
	);
	subinfo "test #1 (as RnRK)";
	$let ()
	(
		$def! (box% box? unbox) () make-encapsulation-type;
		$def! env_tmp_ $provide! (get-count pb) $sequence
			($def! count 5)
			($defl! get-count () count)
			($def! p ($let ((self () get-current-environment))
				(
					$set! self saved_ () lock-current-environment;
					$lazy $if (<=? count 0) count
						($sequence
							($set! self count (- count 1))
							(force p)
							($set! self count (+ count 2))
							count)
				)
			))
			($def! pb box% p);
		$expect 5 () get-count;
		$expect 0 force (unbox pb);
		$expect 10 () get-count;
	);
	subinfo "resolved referencing shared state move;" " fixed since V0.8.57";
	$let ()
	(
		$def! p1 $lazy unit;
		$def! p2 $lazy% p1;
		$let* ((a force p2) (b force p1) (c force (move! p2)))
			$expect (list unit unit unit unit) list a b c (force p1)
	)
);

info "std.strings tests";
$let ()
(
	$import! std.strings string-empty? ++;
	$expect #t string-empty? "";
	$expect #f string-empty? "x";
	$expect "abc123" ++ "a" "bc" "123"
);

info "typing library tests";
subinfo "type?";
$check type? Any;
$check type? List;
$check type? String;
$check type? Number;
subinfo "has-type?";
$check has-type? () Any;
$check has-type? () List;
$check not? (has-type? "" List);
$check (has-type? "" String);
$check has-type? 0 Number;
subinfo "typed-ptree->ptree";
$expect ((unwrap idv) (x))
	(typed-ptree->ptree ((unwrap idv) (x)));
$expect ((unwrap idv) x)
	(typed-ptree->ptree ((unwrap idv) (x : Any)));
$expect ((unwrap idv) (x))
	(typed-ptree->ptree ((unwrap idv) ((x : Any))));
$expect ((unwrap idv) (a n s))
	(typed-ptree->ptree ((unwrap idv) (a n s)));
$expect ((unwrap idv) ((x y z) a n s))
	(typed-ptree->ptree
		((unwrap idv) ((x y z) a n s)));
$expect ((unwrap idv) ((x y z) a n s))
	(typed-ptree->ptree
		((unwrap idv) ((x (y : List) z) (a : Any) (n : Number) s)));
$expect ((unwrap idv) ((x y z) a n s))
	(typed-ptree->ptree
		((unwrap idv) ((x, y : List, z), a : Any, n : Number, s)));

info "typed operations tests";
$let ()
(
	$def! nid lambda ((x : Number)) x;
	$expect 42 nid 42;
	$def! streq? lambda ((x : String) y) eqv? x y;
	$check streq? "x" "x"
);

info "dependency library tests";
$let ()
(
	$expect "1.2.3" version->string (string->version "1.2.3");

	$def! dep-core
		make-dependency "core" (string->version "0.0.1") ($lambda (.) #t);

	$expect "core" name-of dep-core;
	$expect "0.0.1" version->string (version-of dep-core);

	$def! dep-comp1
		make-dependency "comp1" (string->version "0.0.2")
		(strings->dependency-contract "core" "> 0.0.0" "<	0.0.4" "0.0"
			"=0.0.1" "= 0" "	*" "0.*");
	$def! dep-comp2
		make-dependency "comp2" (string->version "0.0.3")
		(strings->dependency-contract "core" ">= 0.0.1" "0.0.*");

	$expect #t validate dep-comp1 dep-core;
	$expect #t validate dep-comp2 dep-core;

	$def! depset1 make-dependency-set dep-comp1 dep-comp2;

	$expect #t has-dependency? depset1 "comp1";
	$expect #f has-dependency? depset1 "comp1" (string->version "0.0.1");
	$expect #t has-dependency? depset1 "comp1" (string->version "0.0.2");
	$expect #f has-dependency? depset1 "comp3"
);

