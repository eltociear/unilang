"#", "(C) 2021-2022 Uniontech Software Technology Co.,Ltd.",
"Unilang test script.";

$import! std.math &=? &<? &<=? &>? &>=? &stoi &itos;

$def! $rem $vau . #ignore "";

info "sanity";
subinfo "empty expression";
$expect ();
subinfo "zeros";
$expect 0 0;
$expect 0 +0;
$expect 0 -0;
$expect 0 00;
$expect 0.0 0.0;
$expect 0.0 +0.0;
$expect 0.0 0.00;
$expect 0.0 00.0;
$expect -0.0 -0.0;
subinfo "id expressions";
$expect 42 $let ((a 42)) a;
$expect 42 $let (('' 42)) '';
$expect 42 $let ((' ' 42)) ' ';

info "function calls";
() $let ()
(
	subinfo "basic combiner calls";
	$defl! g fm apply - fm;
	$defv! $g fm #ignore eval (list* - fm) (() get-current-environment);
	$expect (- 0 1) g 2 3;
	$expect (- 0 1) $g 3 4;
	subinfo "combiner rvalue calls";
	$expect () ($lambda (x) forward! x) ();
	$expect () ($lambda (x) ($lambda (y) idv y) x) ();
	$expect () ($lambda (x) ($lambda (y) id y) x) ();
	$expect "" ($lambda (x) ($lambda (y) ++ y) x) "";
	$expect () ($lambda (x) ($lambda (y)) x) ();
	$expect () ($lambda (x) ($lambda (.)) x) ();
	$expect () ($lambda (x) ($lambda (.) ()) x) ();
	$expect () ($lambda (x) ($lambda (y) y) x) ();
	$expect () ($lambda (x) ($lambda (y) (idv y)) x) ();
	$expect ()
		($def! foo $lambda (z) z; ($lambda (x) ($lambda (y) foo y) x) ());
	$expect () ($lambda (x) ($lambda (y) ($lambda (z) z) y) x) ();
	$expect () ($def! l list (); ($lambda ((&x .)) x) l)
);

info "recursive function calls";
$let ()
(
	subinfo "Fibonacci";
	$defl! fib (&n) $if (<=? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)));
	$expect 8 fib 5;
	subinfo "Hofstadter Female and Male sequences";
	$def! (F M) (list ($lambda (&n) $if (eqv? n 0) 1 (- n (M (F (- n 1)))))
		($lambda (&n) $if (eqv? n 0) 0 (- n (F (M (- n 1))))));
	$expect 5 F 7;
	$expect 4 M 7
);

info "basic object operations";
$let ()
(
	$def! fwd? $vau% (&x) d
		($lambda% (%v) bound-lvalue? ($resolve-identifier v)) (eval% x d);
	$expect (list% #f #f #t #t #f)
		list% (fwd? 1) (fwd? ()) (fwd? fwd?) (fwd? (id fwd?))
			(fwd? (idv fwd?));
);

info "combiner operations";
subinfo "combiner equality";
$let ()
(
	$check eqv? (idv idv) idv;
	$check not? (eqv? (wrap idv) idv);
	$check eqv? (wrap idv) (wrap idv);
	$check eqv? (unwrap unwrap) (unwrap unwrap);
	$def! $quote $vau% (x) #ignore $move-resolved! x;
	$def! idv wrap $quote;
	$check eqv? (unwrap idv) $quote;
	$check eqv? (unwrap (idv idv)) $quote;
	$check eqv? (unwrap idv) (unwrap (idv idv));
	$check eqv? (wrap (unwrap idv)) idv;
);

info "logical operations";
$let ()
(
	subinfo "logical not";
	$expect #t eqv? ($let ((f #f)) not? f) (not? #f);
	subinfo "non-strict logical operations";
	$expect #t () $and?;
	$expect #f () $or?;
	$expect #f $and? #f #f;
	$expect #t $or? #f #t;
	$expect 2 $and? 1 2;
	$expect 1 $or? 1 #f;
	$expect 2 $or? #f 2 #f 3
);

info "list operations";
$let ()
(
	$expect () list* ();
	$expect () list*% ();
	$def! a list 2 3;
	subinfo "list lvalue elements read and move";
	$expect 2 first (id a);
	$expect 2 first a;
	$expect 2 first (as-const (expire a));
	$expect 2 first (expire a)
);

info "local bindings";
() $let ()
(
	$expect () $let ();
	$expect 5 $let ((&x 2) (&y 3)) + x y;
	$expect 4 $let* ((&x 2) (&y x)) + x y;
	$expect 3 $letrec ((x + 0 1) (x 2) (x - 4 1)) x;
	$expect (list 1 2 3) $letrec ((x + 0 1) (y 2) (z - 4 1)) list x y z
);

info "Documented examples.";
$let ()
(
	display "Hello, world!";
	display (display "Hello, world!");
	(display "Hello, world!");
	() newline;
	() display "Hello, world!";
	display "Hello, world!";
	$sequence display "Hello, world!";
	display "Hello, "; display "world!";
	$sequence (display "Hello, ") (display "world!");
	$def! x "hello";
	list "hello" "world";
	cons "x" ();
	list "x";
	cons "x" (cons "y" ());
	list "x" "y";
	$lambda (x) display x;
	$lambda (x) x;
	($lambda (x) display x);
	($lambda (x) (display x));
	$lambda (x y) $sequence (display x) (display y);
	$def! id $lambda (x) x;
	display (($lambda ((x y)) x) (list "hello" "world"));
	$def! car $lambda ((x .)) x; $def! cdr $lambda ((#ignore .x)) x;
	eval (list display "Hello, world!") (() get-current-environment);
	$def! (x y) list "hello" "world"; display x; display y;
	$def! id $lambda (x) x;
	$defl! id (x) x;
	$def! x (); display "x is "; display ($if (null? x) "empty" "not empty")
);

info "Test case on parent environment search.";
$let ()
(
	$def! e make-environment (() get-current-environment);
	eval ((unwrap ($lambda (x) x)) e) e
);

info "make-encapsulation-type";
subinfo "encapsulation values";
$let ()
(
	$def! (e p? d) () make-encapsulation-type;
	p? 1;
	$def! enc e 1;
	$expect #t p? enc;
	$expect #f p? "str";
	$expect 1 d enc;
	$expect 2 d (e 2);
	$expect #t eqv? (e (list 1 2)) (e (list 1 2));
	$expect #f eqv? (e (list 1 2)) (e (list 3 4))
);
subinfo "encapsulation temporary values";
$let ((u unit) (&lt unit) (&t (idv unit)))
(
	$def! (e% #ignore d) () make-encapsulation-type;
	$def! o e% u;
	forward! (d o);
	$expect unit d o;
	$def! o e% lt;
	forward! (d o);
	$expect unit d o;
	$def! o e% t;
	forward! (d o);
	$expect-moved d o
);
subinfo "encapsulation equality";
$let ()
(
	$def! (e #ignore d) () make-encapsulation-type;
	$def! x e 1;
	$def! y e 2;
	$def! z e 2;
	$expect #f eqv? x y;
	$expect #t eqv? y z
);

info "std.promises tests";
$let ()
(
	$import! std.promises
		promise? memoize $lazy $lazy% $lazy/d $lazy/d% force;
	subinfo "value category preservation";
	$let ((p1 $lazy% idv unit))
	(
		$expect unit force unit;
		$expect unit force ($lazy p1);
		force (expire p1);
		$expect-moved force ($lazy p1)
	);
	subinfo "force idempotence";
	$let ((a unit))
	(
		$def! p $lazy a;
		$expect (force p) force p;
	);
	subinfo "lifting safety";
	$let ()
	(
		$defl! me ()
		(
			$def! e () make-environment;
			$set! e x 42;
			e
		);
		$expect 42 force ($lazy/d (() me) x);
		$expect 42 force ($lazy% $lazy/d (() me) x);
		$expect 42 force ($lazy $lazy/d% (() me) x)
	);
	subinfo "test #1 (as RnRK)";
	$let ()
	(
		$def! (box% box? unbox) () make-encapsulation-type;
		$def! env_tmp_ $provide! (get-count pb) $sequence
			($def! count 5)
			($defl! get-count () count)
			($def! p ($let ((self () get-current-environment))
				(
					$set! self saved_ () lock-current-environment;
					$lazy $if (<=? count 0) count
						($sequence
							($set! self count (- count 1))
							(force p)
							($set! self count (+ count 2))
							count)
				)
			))
			($def! pb box% p);
		$expect 5 () get-count;
		$expect 0 force (unbox pb);
		$expect 10 () get-count;
	);
	subinfo "resolved referencing shared state move;" " fixed since V0.8.57";
	$let ()
	(
		$def! p1 $lazy unit;
		$def! p2 $lazy% p1;
		$let* ((a force p2) (b force p1) (c force (move! p2)))
			$expect (list unit unit unit unit) list a b c (force p1)
	)
);

info "std.strings tests";
$let ()
(
	$import! std.strings string-empty? ++;
	$expect #t string-empty? "";
	$expect #f string-empty? "x";
	$expect "abc123" ++ "a" "bc" "123"
);

info "dependency library tests";
$let ()
(
	$expect "1.2.3" version->string (string->version "1.2.3");

	$def! dep-core
		make-dependency "core" (string->version "0.0.1") ($lambda (.) #t);

	$expect "core" name-of dep-core;
	$expect "0.0.1" version->string (version-of dep-core);

	$def! dep-comp1
		make-dependency "comp1" (string->version "0.0.2")
		(strings->dependency-contract "core" "> 0.0.0" "<	0.0.4" "0.0"
			"=0.0.1" "= 0" "	*" "0.*");
	$def! dep-comp2
		make-dependency "comp2" (string->version "0.0.3")
		(strings->dependency-contract "core" ">= 0.0.1" "0.0.*");

	$expect #t validate dep-comp1 dep-core;
	$expect #t validate dep-comp2 dep-core;

	$def! depset1 make-dependency-set dep-comp1 dep-comp2;

	$expect #t has-dependency? depset1 "comp1";
	$expect #f has-dependency? depset1 "comp1" (string->version "0.0.1");
	$expect #t has-dependency? depset1 "comp1" (string->version "0.0.2");
	$expect #f has-dependency? depset1 "comp3"
);

