# 前言(Foreword)

　　本文档是 Unilang 语言的设计规格说明。

## 体例说明

　　本文档中的特定文本（主要用于源代码）使用 `引用文本` 指定。非引用的正常文本适用以下体例。

　　局部的 *术语(terms)* 和 **强调** 的文本以特定的不同于其它正文的格式显示。

　　标记为 **注释** 的文本是*说明性(informative)* 的描述，而不是*正式(normative)* 规则。

　　标记为 **原理** 的文本是阐明语言设计*原理(rationale)* 的**注释**文本。

　　外部文档引用和内部章节引用以[超链接](https://zh.wikipedia.org/zh-cn/%E8%B6%85%E9%93%BE%E6%8E%A5)指定。全文外部引用另见以下的正式引用(normative references) 章节。

　　部分术语或其它名词性文本的特定义项首次出现时使用半角括号标注对应的英文翻译供参照。首字母缩略语(acronym) 和非局部概念的标题使用翻译时，词首字母大写。

　　本文档指定的语言规则(language rule) 中的形式文法(formal grammar) 包括形式语法(formal syntax) 和特定操作的形式，不提供附加的形式语义(formal semantic) 。

　　形式语法的语法类别(syntax category) 以 [BNF](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F) 推导规则表示。

# 绪论(Introduction)

　　Unilang 是一门现代的、模块化的、可移植的和可扩展的通用目的编程语言。

　　Unilang 提供*基础语言(base language)* 和*语言扩展(language extension)* 。基础语言指定基本的语言规则；语言扩展在基础语言之上提供附加的规则，补充或改变语言的特定特性，提供比基础语言更多的实用功能。

**原理** Unilang 强调可扩展性，特别体现在语言特性可通过一个很小的语言核心上通过具有一定可移植性的用户编码的程序添加。基础语言的核心语言规则指定了这种核心的最小要求。一些实用的通用设施则一并以库的形式提供。原则上，一种特性被基础语言作为语言核心特性，仅当这种特性无法通过实现一种新语言规范以外的形式提供。这同时也是拒绝一些特性被核心语言明确支持的理由，特别是并不那么通用的特性——这些特性经常难以被移除而潜在地影响所有场景的所有用户；而通过库的方式，能允许以更灵活的方式可选地实现这些特性而减小矛盾。后者的一个典型例子是*垃圾回收(garbage collection, GC)* 。

## 范围(Scope)

　　本文档描述一个*符合(conforming)* *要求(requirements)* 的基础语言实现需要遵循的规则，这蕴含语言提供的*特性(feature)* 。这些语言特性主要是功能特性；其它的特性通常由语言的实现保证，而不影响*符合性(conformance)*。

　　在基础语言上附加语言扩展得到的*派生语言实现(derivative language implementation)* 可具有不同的语言规则，但应满足本文档中的最小要求以维持符合性。

　　派生语言实现是语言的设计，是抽象的实现。基础语言和派生语言实现都可能有非语言设计形式的具体实现（例如*解释器(interpreter)* ）。不致混淆时，派生语言实现简称*派生实现(derived implementation)* 。一般地，Unilang 语言的*实现(implementation)* 指非语言设计形式的具体实现以及基础语言的派生实现。

　　除非另行指定(specified otherwise) ，本文档的语言规则同时适用于基础语言和派生实现。

## 正式引用

　　本章引用本文档使用的外部参考(external reference) ，包含不被局部术语涵盖的一般解释。对没有指定版本的多版本文献，使用最新的版本。这些引用包括：

* ISO/IEC 2382 (all parts), Information technology — Vocabulary
* ISO/IEC 10646, Information technology — Universal Coded Character Set (UCS)
* ISO/IEC 14882:2017, Information technology — Programming languages — C++
* [Fexprs as the basis of Lisp function application or $vau : the ultimate abstraction](http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf) ([Shu10])
* [Revised<sup>-1</sup> Report on the
Kernel Programming Language](https://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf) ([RnRK])

　　对文献的引用以 [] 包含的形式标记。除以上列表中结尾 () 备注的部分外，包括：

* [ISO C++] ISO/IEC 14882
* [ISO C] ISO/IEC 9899
* [ISO 2382] ISO/IEC 2382

**原理** Unilang 预期实现和 C++ 语言的实现能进行一定程度上的互操作；设计上，和 C++ 等语言也共享一些相似的基本概念。没有在本文档定义的术语可直接引用这些外部参考文献中的定义。[RnRK] 作为本文档中的一些 API 的参考设计来源，也在此一并列出。

# 术语和定义(Terms and Definitions)

* **行为(behavior)** 语言实现或在满足符合性的具体语言实现中的程序的外部表现。
* **程序(program)** 具体语言实现接受的以代码表示的输入，或被变换后对应的输出。
	* 语言实现支持运行*程序(program)* 。除非另行指定，程序指符合本文档要求的 Unilang 代码的输入程序，即 Unilang *源程序(source program)* 。
* **诊断(diagnostics)** 明确的对特定预期或非预期执行的行为的响应的总和。
* **诊断消息(diagnostic message)** 用于和用户交互的表现诊断的告知及提示。
* **未定义的(undefined)** 可能导致违反语言规范的约束但语言规范同时没有要求提供任何可能影响符合性的保证（如具有诊断消息）的。
	* **注释** 表示置于语言规则下的行为等不可预测。
* **未指定的(unspecified)** 规范隐式或显式地允许但不要求唯一确定的至少一个实现选项。
	* **注释** 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。
	* **注释** 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。

* **由实现定义的(implementation-defined)** 取决于各个具体语言实现的，要求有文档说明。
* **由派生实现定义的(derived-implementation-defined)** 取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。
* **未定义行为(undefined behavior)** 未定义的行为。
* **未指定行为(unspecified behavior)** 未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。
	* **注释** 推论：由实现定义的行为是未指定行为。
* **未指定行为(unspecified behavior)** ：未指定的行为。
	* **注释** 由实现选取规格中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。
	* **注释** 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。

**注释** 一些术语和 [ISO C++] 类似，但在此显式定义。[ISO C++] 对 [ISO C] 具有类似的处理，但不尽相同。例如，ISO C 中由实现定义的行为是未指定行为（的子集），而 ISO C++ 中由实现定义的行为的定义不依赖未定义行为的定义，但逻辑上实质等价；而 ISO C 的未指定行为依赖*未指定值(unspecified value)* 的定义，但 ISO C++ 则依赖抽象机的选择动作直接定义未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。

# 计算模型

　　本文档的 Unilang 语义规则以*抽象机(abstract machine)* 的形式提供。抽象机可具有*可变状态(mutable state)* 。

　　Unilang 程序的*执行(execution)* 可包括不同的*计算作用(computational effect)* ，简称*作用(effect)* ，包括：

* 确定一个作为计算结果的*值(value)* 。
* 改变抽象机中的可变状态。

　　后者称为*副作用(side effect)* ，包括：

* 特定的对象访问：改变抽象机中的可被程序*访问(access)* 的可变状态。
* *控制作用(control effect)* ：改变之后会被执行的程序。

**注释** Unilang 不是所谓的纯函数式语言，其中的计算允许描述状态的改变。表达式的求值的计算作用和 [ISO C] 以及 [ISO C++] 类似。不同的是，本文档的定义明确指定控制作用的更一般外延。特别地，最简单的条件分支也明确具有副作用。

**原理** 与一些简单认知不同，不限制计算蕴含副作用的上下文实际上不阻碍允许实现[引用透明性](http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf)。这也使理论模型（操作语义意义上）更加清晰一致并可直接扩展。例如，语义允许简单分支被表达为（派生实现定义的）异常控制流一并分析，而不需要首先假定分支总是被翻译为分支指令等内部表示形式才能应用 [SSA](https://en.wikipedia.org/wiki/Static_single_assignment_form) 等形式的中间表示。 

　　派生实现可定义其它的作用。

　　为约束作用的顺序，两个作用 A 和 B 之间可能具有以下二元关系：

* *先序(sequenced before)* 关系是两个作用之间存在的一种*偏序关系(partial order)* 
* *后序(sequenced after)* 是先序的逆关系。
* *非决定性有序(indeterminately sequenced)* 是先序或后序的并集。
* *无序(unsequenced)* 是非决定性有序在作用之间的顺序二元关系全集上的补集。

　　除非另行指定，任意两个作用之间是无序的。

　　除非另行指定，副作用构成实现接受程序时具有的*可观察(observable) 行为*。

# 符合性(Conformance)

　　本文档指定 Unilang 程序的语言规则，包括语法和语义规则，以及实现环境应提供的程序接口。

　　Unilang 的实现翻译程序到适当的目标代码的形式。翻译的输入是源程序。翻译的直接输出可能是外部环境不可见的，即*解释(interpret)* ；也可以是确定具体形式的，即*编译(compile)* 。

　　一个符合本文档的实现应支持能接受符合规则的程序作为翻译的输入，并按本文档约定的规则中的要求表现计算作用影响的行为。

　　基础语言不要求实现蕴含不同的执行阶段。

**注释** 特定的程序是 *AOT(ahead-of-time)* 翻译的，翻译总在执行时的余下阶段之前进行，余下的阶段运行程序。基础语言是否使用 AOT 翻译实现未指定。因为一些动态特性，全局的 AOT 缺乏现实意义；实现仍可局部地替换局部的求值为多阶段翻译而允许相对直接解释更好的性能表现。

**原理** 除非实现新的语言，直接指定的多实现阶段不容易在基础语言中移除。而从没有指定多执行阶段的实现中添加阶段相对更容易实现。同时，这种方式能使用户自行替换多阶段翻译的实现，而不影响可移植性，获得比传统 AOT 编译器更好的适应性。

　　若程序具有未定义行为，则对实现没有任何要求，包括是否接受源程序的判定。

## 诊断(Diagnostics)

　　Unilang 要求具体实现对不满足语言规则约束的特定情形给出诊断。这类规则是*可诊断的(diagnostable)* 。

　　本文档中，*引起(signal)* 指定为*错误(error)* 的条件明确要求诊断。

　　违反语法规则的的情形是错误。

　　程序的语法性质和部分语义性质在翻译时检查，通过检查则应接受翻译，否则应提供诊断。

　　一次翻译接受的源代码是一个*翻译单元(translation unit)* 。对语法规则的检查以不大于翻译单元的单位整体进行。对未通过语法规则检查的诊断应至少能明确区分具体失败的翻译单元。

　　对象操作可能进行*检查(check)* 。检查失败引起错误。

　　特定的错误在程序运行中以*抛出(throw)* 特定的*异常(exception)* 的形式实现。抛出的异常中断当前的程序，直至被*处理(handle)* 或程序终止。实现可提供处理异常的默认行为以避免程序终止。

## 最小符合性要求

　　Unilang 具体实现应满足以下最小符合性要求：

* 以翻译单元为单位进行翻译，满足：
	* 翻译接受*合式的(well-formed)* ，即符合语法规则和可诊断语义规则的程序。
	* 对*不合式的(ill-formed)* 程序，若不存在未定义行为，则要求翻译提供诊断消息并拒绝接受程序而终止程序的运行。（对 AOT 翻译实现，则直接终止翻译。）
* 对合式的程序，具体实现的行为符合抽象机语义蕴含的可观察行为。

　　注意可观察行为以外的具体实现行为和抽象机的行为的一致性未指定。这允许*优化的(optimimal)* 实现省略不影响可观察行为的计算作用。

# 词法规则(Lexical Rules)

　　*分隔符(delimiter)* 是标记代码片段中特定位置的特定字符序列，是*词素(lexeme)* 的间隔。识别词素后，每个词素按照构成字符的不同，被分为不同的*记号(token)* 类别。

　　记号类别包含*标点(punctuator)* 、*字面量(literal)* 和*标识符(identifier)* 。

　　代码中邻接的分隔符和非分隔符的字符序列不构成一个词素。分隔符包括不在记号中包含的空白符(whitespace) 构成的字符序列以及标点。字面量以外的记号不包含空白符。

　　超过一个字符的标点可能在匹配字符序列确定是否构成词素时具有词法歧义。此时，应指定消歧义规则确保存在唯一可接受的匹配方式，或引起词法错误终止翻译。

**注释** 当前设计中没有这样的标点。

　　基础语言识别的标点包括语法规则要求的标点 `(` 和 `)` ，以及中缀变换的标点。详见以下相关章节。

　　字面量包括：

* 以特定的字符作为词素起始和结尾，中间包含决定字符序列作为内容的*字符串字面量(string literal)* ：
	* 以 `"` 作为词素起始和结尾的*数据字面量(data literal)* 。
	* 以 `'` 作为词素起始和结尾的*代码字面量(code literal)* 。
* 包含数字字符的*数值字面量(numerical literal)* ：
	* 词素匹配正则表达式 `(+|-)?[0-9]+` ：十进制整数数值。
	* 词素匹配正则表达式 `(+|-)?[0-9]+\.[0-9]*` 或 `(+|-)?[0-9]+(\.[0-9]*)?(E|e)(+|-)?[0-9]+` ：十进制小数数值。
	* 两种形式分别是直接记法和科学记数法(scientific notation) 。
		* 科学记数法中，指数字母 `e` 或 `E` 含义一致；前后的数字序列分别是有效数字(significand) 和指数(exponent) 。
	* 词素匹配正则表达式 `(+|-)(inf|nan).(0|f|t)` ：特殊值。
* 以 `#` 起始的字面量：
	* `#t` 和 `#f` 表示逻辑真和逻辑假。
	* `#inert` 指定特定操作中表示被忽略的结果。
	* `#ignore` 指定特定操作中代替标识符作为被忽略匹配的占位符。

**注释** 字面量的语义参见以下关于求值算法的描述。

　　特定的记号中的字符序列是*转义(escape)* 字符序列。确定词素时，转义字符序列首先被替换为被转义的字符。以下转义字符序列被基础语言直接支持：

* `\'` ：转义 `\` 。
* `\"` ：转义 `"` 。
* `\\` ：转义 `\\` 。
* `\a` ：转义响铃符 BEL 。
* `\b` ：转义退格符 BS 。
* `\f` ：转义换页符 FF 。
* `\n` ：转义换行符 NL(LF) 。
* `\r` ：转义回车符 CR 。
* `\t` ：转义水平制表符 HT 。
* `\v` ：转义垂直制表符 VT 。

**注释** 这些转义字符序列同 [ISO C++] 支持的转义字符的含义。和 [ISO C++] 不同，不匹配转义字符序列的其它字符序列不被替换；单独的 `\` 不引起诊断。

　　派生实现可在此之外定义其它记号类型和扩展的标点，后者应符合 C++ ([ISO C++]) 的定义。

　　派生实现也可定义*预处理(preprocessing)* 过程翻译其它表示为包含 Unilang 基础语言接受的词法形式的翻译单元，以支持不同的词法和语法规则。

# 语法

　　Unilang 基础语言的语法以基本语法和可通过前置预处理实现的*中缀变换(infix transformation)* 规则定义。

## 基本语法

```
<expression> ::= <atom-expression> | <composite-expression> | <list-expression>
<composite-expression> ::= <token-expression> | <expression-token>
<atom-expression> ::= <token>
<list-expression> ::= <left-list-bound> <expression>* <right-list-bound>
<left-list-bound> ::= ( | <extended-left-list-bound>
<right-list-bound> ::= ) | <extended-right-list-bound>
```

　　Unilang 基础语言的翻译单元以*表达式(expression)* 作为语法单位。一个表达式可以是：

* 不可拆分为其它表达式的*原子表达式(atom expression)* 。
* 由派生实现定义的，记号和其它表达式直接*并置连接(juxtaposition)* ，之间没有其它记号的表达式。
* 由分隔符作为边界的包含若干个*子表达式(subexpression)* 的*列表表达式(list expression)* 。

　　原子表达式在词法上是一个记号。

　　以下词法构造在基础语言中是空集，可由派生实现定义：

* `<extended-left-list-bound>`
* `<extended-right-list-bound>`
* `<token-expression>`
* `<expression-token>`

## 中缀变换

　　中缀变换递归替换构成表达式的形如 `<expression> (<infix> <expression>)*` 的记号序列为 `<transformed-infix> <expression>+` 形式的记号序列。

　　其中，基础语言支持的中缀记号 `<infix>` 是 `;` 或 `,` ，而 `<transformed-infix>` 是语法不可见的中缀变换函数。

　　变换的不同 `<expression>` 的实例以相同的词法顺序在变换后的结果中被保存。

　　变换后的结果符合以上的基本语法规则。

# 语义

## 实体模型

　　Unilang 的程序操作*实体(entity)* 。

### 对象和值

　　区分*同一性(identity)* 的实体是*对象(object)*。同一性决定语言的不同表达式可以描述的相同的对象。

　　不区分同一性的特定的实体是*值(value)* 。

**注释** 同一性事实上表现了一般意义上的对象的[左值性](https://classes.cs.uoregon.edu/14S/cis607pl/Papers/fundamental-1967.pdf)。另见以下表达式的值和值类别的相关规则。

### 可变性

　　对象可能具有*可变(mutable)* 状态，是可变的对象；对象也可能总是具有一种不被预言分辨的状态，是*不可变(immutable)* 的。其它实体是不可变的。

　　可变对象允许*改变(mutate)* 使对象具有不同的状态。

　　不可变对象仍允许指定内部的*可变管理状态(mutable administrative state)* ，以具有改变这些内部状态而不被视为对象整体上进行改变的操作。这类对象具有*内部可变性(interior mutability)* 。

**注释** 内部可变性的可变管理状态类似 [ISO C++] 的类的 `mutable` 数据成员表达的状态，因为它不影响 `const` 可修改性（在此视为可变性的一个实例）类型检查。

　　除非另行指定，对象上的所有操作都允许的不要求诊断错误的改变操作隐式地指定可变管理状态的改变。

　　语言实现可定义其它的机制明确同一性或外延的其它实体。

### 类型

　　值和由派生实现定义的特定的其它实体可以具有*类型(type)* ，以明确*外延(extension)* 。

　　没有明确指定具有特定类型的实体视为具有*对象类型(object type)* 。

**注释** 表达式不要求具有特定的类型，而总是具有对象类型。

　　类型被视为一种值，其外延是类型*全集(universe)* 。语言支持非特定的开放的(open) 类型系统(type system) ，允许派生实现扩展。但本文档中，类型全集总是包含任意经扩展的所有类型的集合。

　　*子类型(subtyping)* 关系类型是类型全集上的一个预序(preorder) 关系。除非另行指定，特定的子类型关系同时是严格的(strict) ，构成偏序关系(partial order) 。

**注释** 即子类型关系是传递对称的二元关系。严格子类型关系是反自反的子类型关系。

　　特定的语言规则可明确某一些值具有明确指定的类型，或者具有某个类型的未指定的子类型。

　　除非另行指定：

* 其它任意类型都是对象类型的子类型。
* 不具有子类型关系的类型之间不相交。
* 不相同的类型的值之间不相同。

**注释** 类型一般建模为集合论意义上的*集合(set)* 。逻辑上，集合是类型的一种*释义(interpreation)* 。这种集合中的元素是可能作为类型*居留(inhabitant)* 的值。子类型关系可建模为表示类型的集合之间的子集。

### 实体的值

　　对象总是关联特定类型的值作为它的内容，称为对象的值。除非另行指定，对象的类型是对象的值的类型。

**注释** 按以上的实体的类型的规则，对象总是具有对象类型。

　　对象的值是对象的状态的一部分。对象的值的不可变性蕴含对象的不可变性，但反之不保证。这允许实现在对象中保存不影响值但仍可影响可观察行为的状态（例如同步需要的锁定状态）。

　　因为明确同一性，特定的对象实例总是可被*创建(create)* 或*销毁(destroy)* ，且可能影响可观察行为。

　　类似地，不明确同一性的一般实体可具有关联的值，但不保证作为其状态的一部分。

### 初始化

　　对象被创建后可通过*初始化(initialization)* 决定其值，并可能存在其它[作用](#计算模型)。被决定的值是*初始值(initial value)* 。

　　决定这些作用的表达式是初始化的*初值符(initializer)* 。

　　初值符的求值可能有[副作用](#计算模型)，其求值结果指定特定被初始化的对象的初始值。

　　初始化可使创建的对象作为其它对象的副本，这种初始化称为*复制初始化(copy initialization)* ；此时，其它对象的值不一定保持不变。其它实体的初始化称为*直接初始化(direct initalization)* 。

**注释** 初值符的求值的副作用不属于初始化，其求值结果和对象的初始值不一定相同。

### 对象的存储期和生存期

　　程序执行时，对象占据存储资源，具有存储期。每个被创建后和销毁前的对象具有一段连续的*生存期(lifetime)* 。生存期是存储期的子集。

**注释** 这和 [ISO C++] 的对象的对应性质相同。

　　确定对象的值或改变对象的值访问对象。

　　在生存期外访问对象是受限的；除非另行指定，在生存期外访问对象的程序具有未定义行为。

### 内存安全

　　*内存安全(memory safety)* 是存储资源避免特定类型不可预测错误使用的性质。

　　基本的内存安全保证蕴含非并发访问时不引起未定义行为。这至少满足：

* 对对象占据的存储的访问总是在提供存储的对象的存储期内；
* 不访问对象的未被初始化的值。

　　特定的操作保证内存安全。

**注释** 内存安全不包含并发访问安全。当前语言不提供避免并发访问时可能具有数据竞争的机制。

**注释** 和宿主实现的互操作可能影响内存安全保证的实现。

**注释** 和许多语言的定义类似，内存安全不包含排除内存相关的*资源泄漏(resource leak)* 。但是，通过禁止[循环引用](#引用值)可避免一些原生引入的资源泄漏。

### 对象的所有权和子对象

　　一个或多个对象可具有另一个对象的*所有权(ownership)* ：前者约束后者的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集。

　　一个对象可以具有若干个*子对象(subobject)* ，在创建后创建子对象，在销毁前销毁子对象，而具有子对象的所有权。

　　类似地，对象可以对内部隐含的不以对象的方式可访问的资源实体具有所有权。

　　所有权作为实体上的二元关系，满足反自反、反对称和传递性。

### 对象的其它元数据

　　除以上性质外，对象可关联其它元数据以指定对象属性。不在语言中要求直接可被访问的实体统称为*标签(tag)* 。

　　对象具有的标签决定以下正交的性质：

* 唯一(unique) 引用：指定对象的值关联到自身以外的不被其它对象*别名(aliasing)* 的对象。以唯一引用关联的对象进行复制初始化时，不需要保留关联的对象的值。
* 不可修改(nonmodifying) ：指定对象的值保持不变（类似 [ISO C++] 的 `const` 类型的值）。若操作需要修改此对象，则引起错误。
* 临时(temporary) 对象：指定对象的值被临时使用。类似唯一引用，但限定的是对象自身而非关联的其它对象。

**注释** 对象的标签不在大多数对象中可见。关于其主要应用，参见[引用值](#引用值)。

## 表达式的值和类型

　　表达式通过*求值(evaluation)* 进行计算并体现计算作用，其中可确定表达式的计算结果作为关联的值，即表达式的值。

**注释** 关于求值的过程和相关规则，详见以下[求值算法](#求值算法)中的描述。

　　被求值的表达式的类型是表达式的值的类型。

　　在语法规则之上，基础语言约定可能*未求值的(unevaluated)* 表达式作为对象也具有值。Unilang 翻译单元中，未求值的表达式满足以下性质：

* 作为记号的标识符是*符号(symbol)* ，是符号类型的值。
* 列表表达式中若不含有子表达式，则这个表达式是空列表；否则，是非空列表。

　　空列表和非空列表统称列表，其中包含的子对象是列表的元素。未求值的非空列表中，子表达式是列表的元素。

　　更一般地，Unilang 还支持逻辑上具有两个元素构成的*有序对(pair)* 。当且仅当一个有序对的第二个元素是列表时，这个有序对是列表。

　　非空列表可被分解表示为列表的第一个元素和列表的剩余元素构成的列表的有序对。当存在剩余元素时，构成的这个有序对的第二个元素是非空列表，可继续分解为有序对表示。因为列表具有有限个元素，总能通过有限次分解得到所有列表的元素和一个非空列表构成的序列。这称为列表的完全分解。

**注释** 一些编程语言中，这种有序对通过 `cons` 构造，因此又称为 cons 对。

　　*子有序对(subpair)* 是一个有序对完全分解的序列中的元素的真子集构成的子对象。

　　*子列表(sublist)* 是一个列表中的元素的真子集构成的列表子对象。

　　除非另行指定，Unilang 的列表是*真列表(proper list)* ：列表的元素有限，同一个列表的不同元素之间不具有相互的所有权，生存期不相交。

　　有序对中列表的补集是*非真列表(improper list)* 。类似列表，非真列表可被完全分解为其元素和一个不是空列表的对象构成的序列。

**注释** 符号、空列表和有序对同时作为未求值和求值的表达式的值，被求值算法依赖，是 Unilang 的最基本的类型。其中，非真列表的不在翻译单元直接提供表达方式，而需要求值表达式得到。

## 表达式的值类别

　　根据求值的结果表达的含义，表达式有以下基本分类：

* *泛左值(glvalue)* ：求值用于决定被表示的对象的同一性的表达式；
* *纯右值(prvalue)* ：求值不用于决定对象同一性（而仅用于初始化临时对象或计算对象中存储的值）的表达式。

　　一个泛左值可能被标记为*消亡值(xvalue)* ，以提供基于不同的所有权的行为。

　　纯右值蕴含对象在可观察行为的意义上不被共享。

　　*左值(lvalue)* 是除了消亡值外的泛左值。*右值(rvalue)* 是消亡值或纯右值。

　　表达式不限定从源代码确定，且一个表达式的[求值结果](#求值算法)不排除继续构成表达式而被[求值](#求值算法)，因此表达式的值也普遍具有值类别。一等对象的值的类型和值类别存在以下一一对应关系：

**注释** 和 ISO C++ 不同，Unilang 表达式，可能在程序运行时确定，由此确定的表达式的值类别不保证通过程序的静态构造直接确定。特别地，表达式可被求值为不一定具有相同值类别的其它表示，这种求值在 ISO C++ 中若和上下文相关（如左值到右值转换），其中上下文能通过程序的静态构造确定，但在 Unilang 中则不一定。

　　除非另行指定，被求值的表达式的值类别是表达式求值结果的值类别。

**注释** 基于求值结果的值类别约定被求值的表达式的值类别是自然的，因为被求值的表达式自身的值类别通常不被关心（尽管在求值前，可构造表达式的副本以便用于其它求值，此时其值类别可能被关心）。这也和 ISO C++ 更加一致，尽管后者通过上下文（如 ISO C++ 的未求值操作数(unevaluated operand) ）就足够排除不同情形。但注意，表达式的值可能是左值，和右值不等价，这和 [ISO C] 的一般约定不一致。

　　具体表达式的值类别由本文档约定的求值算法和具体操作确定。

## 引用值

　　特定的值是*引用值(reference value)* ，具有引用类型。引用值关联到*被引用对象(referent)* 。

　　*子有序对引用(subpair reference)* 是[子有序对](#表达式的值和类型)作为被引用对象的引用。

　　*子列表引用(sublist reference)* 是[子列表](#表达式的值和类型)作为被引用对象的引用。

　　子有序对引用和子列表引用是*子对象引用(subobject)* 。语言可能引入其它的子对象引用。子对象引用对特定操作可表现和其它一等对象不同的行为。

　　除非另行指定，构造任意的循环引用引起未定义行为。[有序对](表达式的值和类型)中不支持引用构成环，[列表](表达式的值和类型)和[非真列表](表达式的值和类型)都保证是无环的(acyclic) 。

**原理** 实现可假定对象的表示中的子对象的所有权关系构成无环图。

### 多重引用

　　被引用对象也可以是引用值。

**注释** 这和 [ISO C++] 等语言中的引用不同。

　　被引用对象不是引用值的引用值是完全折叠(fully collapsed) 的。

　　除非另行指定，未折叠的引用值指未完全折叠的引用值。

　　引用值的直接或者间接的被引用对象是自身时构成循环引用。

**注释** 构造引用自身的循环引用引起未定义行为。

### 引用值的属性和子类型

　　引用值具有*属性(property)* 。指定的引用属性可以是：

* 唯一引用；
* 不可修改引用；
* 临时对象引用。

　　对引用值的操作*传播(propagate)* 特定的引用属性，当且仅当若操作数是具有特定引用属性的引用值，且结果是引用值时，结果具有和操作数相同的特定属性。

　　唯一引用和临时对象引用是*右值引用(rvalue reference)* ；其它引用值是左值引用。两者是引用类型的[子类型](#类型)。

**注释** 引用类型和其它对象的类型不同（不相交），因此这些子类型和非引用类型也不相交。

　　引用值的类型和具有这个引用值的表达式的值类别存在以下一一对应关系：

* 若值的类型是引用，则对应的值类别是泛左值：
	* 若类型是左值引用，则对应的值类别是左值；
	* 若类型是右值引用，则对应的值类别是消亡值；
* 否则，对应的值类别是右值。

**注释** 临时对象引用类似 [ISO C++] 中延长对象生存期的引用，而唯一引用类似 [ISO C++] 中其它情形的右值引用。和 [ISO C++] 不同，引用值的被引用对象是一等对象，可能仍是引用值，这种转换的结果并非保证纯右值。唯一引用类似 [ISO C++] 的右值引用。

**注释** 关于作为临时对象引用的被引用对象，参见以下[临时对象](#临时对象)的描述。

　　引用值的属性和作为对象的引用值的标签对应，但和一般意义的对象具有的标签相对独立：引用值的属性对应被引用对象（而非引用值自身）的标签。

**注释** 临时对象的引用值不是[消亡值](#表达式的值类别) ，但在特定的上下文中允许近似消亡值的行为。这类似 ISO C++ 中的完美转发(perfect forwarding) 中的模板形式参数类型中的类型占位符 `&&` 。

### 引用值的访问

　　除非另行指定，访问引用值总是等价于访问其被引用对象，这称为*左值到右值转换(lvalue-to-rvalue conversion)* 。例外而不进行这种转换的上下文中，引用值被*保留(preseved)* 。

**注释**

* 同一般对象，被引用对象的访问应在生存期内，否则程序行为未定义。
* 值类别、左值引用、右值引用及左值到右值转换和 [ISO C++] 的同名特性类似，后者实际上转换泛左值到右值。同 [ISO C++] ，左值到右值转换的左值也适用于泛左值。
* 作为更一般的情形，左值到右值转换符合[值类别转换](#值类别转换)的规则。

### 引用值的消除

　　引用值可被消除，即被其（可能多重）引用关联的被引用对象替代。

　　未折叠的引用值消除一次引用值，结果仍是引用值。

　　消除完全折叠的引用值的结果总是右值。

**注释** 推论：因为引用值[不循环引用自身](#多重引用)，除非引用值已[完全折叠](#多重引用)，继续消除引用值得到的值和引用值是不同的值。

### 引用值和初始化

　　引用值可使用被引用对象作为初值进行直接初始化。

　　初值是引用值时，初始化的引用值的被引用对象可能是初值的被引用对象，同时[传播不可修改属性](#引用值的属性和子类型)，这种情形称为*引用折叠(reference collapse)* 。其它情形初始化的引用值的被引用对象是初值。

　　是否发生引用折叠依初始化发生的具体上下文而定。引用折叠的结果是唯一引用的一个必要条件是被引用对象是右值引用。

**注释** 引用折叠类似 [ISO C++] 的同名特性操作。但与 C++ 不同，引用值是一等对象，在某些保留引用值的实现相关的上下文中，被引用对象允许不发生引用折叠而直接使初始化的引用的被引用对象是引用值。

**注释** 引用折叠传播不可修改属性类似 [ISO C++] 的引用折叠对 `const` 引用中类型限定符的处理，满足 `const` 类型安全性。

### 对象的可转移条件

　　*可转移(movable)* 的对象通过以下规则确定：

* 非引用值的对象总是可转移的。
* 引用值关联的被引用对象可能是可转移的：
	* 若引用值具有的标签是被引用对象的唯一引用且非不可修改，被引用对象是可转移的。
	* 若引用值由临时对象初始化，被引用对象（即此临时对象）是可转移的。

　　若满足上述可转移对象条件的对象通过复制初始化创建对象副本，则对象被转移，被转移的对象的值在转移后未指定；否则，对象被复制，被复制的对象在复制后的值保持不变。

　　被转移后的对象具有*有效但未指定(valid but unspecified)* 的值。

**注释** 这和 [ISO C++] 相同。

## 值类别转换

　　具有特定值类别的表达式可转换为不同值类别的表达式：

* 除非另行指定，泛左值总是允许作为纯右值使用。从泛左值取对应右值的操作称为[左值到右值转换](#引用值的访问)。
* 从纯右值初始化可作为一等对象使用的[临时对象](#临时对象)的引用值作为[消亡值](#表达式的值类别) ，称为*临时对象实质化转换(temporary materialization conversion)* 。

　　左值到右值转换没有副作用。临时对象实质化转换没有副作用，当且仅当其中初始化临时对象时没有副作用。

　　临时对象实质化转换中，纯右值被*实质化(materialized)* 。

　　在求值子表达式时，按表达式具有的语义，必要时进行值类别转换。

　　语言还提供引用值提升转换。以下规则确定引用值提升转换的结果：

* 若操作数是引用值，则结果是操作数的被引用对象。
* 否则，结果是操作数。

**原理** 为支持引用值作为一等对象（特别是未折叠的引用值），语言提供比左值到右值转换更精细的引用值提升转换。

**注释**

* 根据引用值的性质，易知左值到右值转换的规约是引用值提升转换的规约的传递闭包，即：
	* 若操作数是[已完全折叠的引用值](#多重引用)，则引用值提升转换等价左值到右值转换。
	* 否则，有限次的引用值提升转换等价左值到右值转换。
* 引用值提升转换不传播引用值的属性。
* 引用值提升转换不传播不可修改属性，类似 [ISO C++] 非引用值的转换在结果中不保留源操作数中的 `const` 类型。

### 返回值转换

　　程序在一些需要引用值的被引用对象的上下文中使用返回值转换：一次引用值提升转换和可选的临时对象实质化转换的复合。

**注释** 实现可消除引用值而避免创建冗余对象的开销。

**注释** 以下操作是引用值的消除：

* 当引用值提升转换的操作数是引用值时，消除被提升的引用值；
* 当[引用折叠](#引用值和初始化)的操作数是引用值时，消除被折叠的引用值。

　　临时对象可直接初始化引用值。和非临时对象的引用值不同，临时对象初始化的引用值和关联的被引用对象之间不需要区分同一性，因此使用被引用对象添加临时对象标签表示。

　　从纯右值初始化临时对象作为消亡值，称为*临时对象实质化转换(temporary materialization conversion)* 。

**注释** 这类似 [ISO C++] 引入临时对象的相同特性。

## 临时对象

　　特定的非一等对象是临时对象，这包括临时对象引用的被引用对象。

　　Unilang 允许（但不要求支持）通过一等对象构成的表达式的特定求值，在中间结果中蕴含这种非一等对象。

**注释** 这些对象不在源语言中可见，一般仅用于互操作。

　　语言在特定的上下文引入其它临时对象，包括：

* 实质化转换上下文：
	* 使用纯右值初始化按引用绑定的变量（如函数的引用类型的形式参数）。
	* 求值[函数调用](#函数)以初始化函数值。
* 返回值转换上下文：
	* [返回值转换](#返回值转换)可引入实质化的临时对象，其中[可能转移求值](#对象的可转移条件)的中间结果；否则，对象被复制。
	* 除非另行指定，被转移的对象不在语言中可被访问。

**注释**

* 实质化转换上下文可具有（但不保证具有）临时对象实质化转换。
	* 不要求具有转换允许[复制消除](#复制消除)。
	* 在不具有转换时，优化实现可能展开内联函数调用而消除需要的对象分配，并同时实现复制消除。
* 仅在对象被复制且复制具有副作用时，返回值转换具有等价复制的副作用。

### 复制消除

　　临时对象在特定的上下文被要求*复制消除(copy elision)* ，排除复制或转移操作且保证被消除操作的源和目的对象的同一性。

　　复制消除仅在以下转换上下文中被要求，即直接使用被转换的源表达式中的对象作为实质化的对象而不初始化新的临时对象：

* 实质化转换上下文。
* 引起[对象转移](#对象的可转移条件)至函数值的返回值转换上下文。

**原理**

* 为维护语言规则的简单性和使用这些规则的程序的行为的易预测性，复制消除限于临时对象的消除。
* 复制消除的目的 [ISO C++]（自 C++17 起）类似。同时，提供语言支持也允许更简单地实现 C++ 互操作性。
* 和 [ISO C++] 不同的一些要求可简化语言规则和实现，例如：
	* 不区分求值结果是否被作为返回值或求值是否为常量表达式。
	* 不要求 `return	 语句中的特定的表达式，而不需要依赖特定上下文的语法性质。
	* 同时，不限制对象的类型（ISO C++ 则要求特定的 C++ 类类型）。

* 实质化转换上下文：
	* **注释** 这些上下文可要求临时对象实质化转换。
	* 使用纯右值初始化按引用绑定的变量（如函数的引用类型的形式参数）。
	* 求值函数调用以初始化返回值对象。

**原理** 为语言规则的简单性和使用这些规则的程序的行为可预测性，复制消除限于临时对象的消除。

## 变量和环境

　　*变量(variable)* 是具有*名称(name)* 的实体，参见 [ISO 2382]。

　　变量是在*环境(environment)* 对象中存储的*绑定(binding)* 的集合，即名称到实体的映射。被绑定的实体总是[一等对象](#一等实体)，称为*被绑定对象(bound object)* 。

**注释** 形式地，变量绑定形式定义变量的名称和被绑定对象的有序对。这里的有序对不需要是语言中的数据结构。

　　环境对象对其中的被绑定对象具有所有权。

　　被绑定对象是环境的[可变管理状态](#可变性)。

　　语言中的环境以*环境引用(environment reference)* 的形式作为[一等对象](#一等实体)。环境对象自身在语言中不可见，必须通过环境引用访问。

**注释** 环境引用不是[引用值](#表达式的值和值类别)。后者关联的被引用对象是一等对象。

　　环境对象可能被环境共享。一个环境引用可能是*强引用(strong reference)* 或*弱引用(weak reference)* 之一。关联到相同的环境对象的环境强引用对关联的环境对象具有共享的[所有权](#对象的所有权和子对象)。

　　一个环境是*空环境(empty environment)* ，当且仅当其中的绑定是空集。

　　环境可以引用零个或有限多个*父环境(parent)* 。环境的父环境在创建时指定，之后不可变。

### 新环境

　　*新环境(fresh environment)* 是新创建的环境。除非另行指定，新环境是不存在能引起程序行为改变的父环境的空环境。

### 隐藏环境

　　语言实现可提供环境对象以外的非一等环境（详见以下一等实体的描述）。总是不能以一等对象访问的环境是*隐藏环境(hidden environment)* 。

**注释** 一般地，隐藏环境是某一个（非隐藏的）一等环境的直接或间接父环境（而能通过求值等间接操作被访问）。

### 稳定性

　　环境在特定情形保证*稳定性(stability)* ：一个环境是*稳定的(stable)* ，仅当总是可假定绑定维持一定意义的等价性，而可确保访问其中同名实体的可观察行为等价。

**注释** 推论：稳定环境中的同名被绑定对象可证明排除通过对象的引用使其改变的副作用（如被修改）或总是具有同一性。

**原理** 从稳定的环境多次访问对象的计算作用是幂等的。这允许合并多次访问为一次而不改变程序的行为，允许具有较小的实现开销。

　　违反关于环境稳定性的要求的程序具有未定义行为。

**原理** 环境稳定性不易被可靠地判定甚至不可能被判定（例如，一个无法检查但可信的来源提供的环境），因此语言规则在此不要求进行检查。要求隐藏环境稳定允许实现共享隐藏环境作为父环境而提供标准环境。

　　任意[隐藏环境](#隐藏环境) `e` 应满足以下绑定有效稳定性：

　　通过引用值间接访问 `e` 中绑定的对象时绑定保持有效（蕴含不被移除或重绑定），保持被绑定对象的生存期和 `e` 对其的所有权。

　　任意隐藏环境的 `e` 的任意同一被绑定对象 `o` 应满足以下的值稳定性：

　　若 `o` 上发生使其改变的副作用（如被修改），则之后在以 `e` 或任意以 `e` 作为直接或间接父环境的环境中直接以名称解析或 `o` 的引用值访问 `o` 时，`o` 的值和发生作用前的 `o` 的值在影响可观察行为的意义上等价。

**注释**

　　以下情形发生的使对象其改变的副作用不受值稳定性要求的约束：

* 对象通过合并子调用的返回值或其中的[子对象引用](#引用值)指定（不论合并子是否是隐藏环境中的子对象）；
* 对象通过间接访问具有内部可变性的对象的可变管理状态。

　　后者的一类典型实例是一等环境中的绑定中的子对象（即便这个一等环境对象是隐藏环境中的子对象）。

### 冻结

　　环境可被*冻结(freeze)* 。冻结后的环境中取得的绑定和引用值不可修改。

　　特定的环境修改要求环境不在冻结状态以确保不变量，要求类型检查。检查失败则引起类型错误。

　　冻结一个已被冻结的环境没有作用。

　　隐藏环境是冻结的。

　　语言不提供在已有环境撤销冻结的方法和在冻结的环境中添加、移除绑定或重绑定的方法。

### 名称解析

　　给定一个名称，在环境中确定被名称指称的对象，称为*名称解析(name resolution)* 。

　　*名称查找(name lookup)* 在指定的环境中搜索和给定名称相同的绑定，当且仅当存在这样的绑定，名称查找成功。

　　基础语言使用以下名称解析算法：

1. 若名称查找成功，名称解析的结果对象是对应的被绑定对象。
2. 否则，按创建环境时指定的顺序，深度优先搜索父环境中的绑定，搜索到的第一个确定对应的绑定的对象是名称查找的结果对象。
3. 否则，名称解析失败，引起错误。

　　成功的解析确定的对象以引用结果对象的引用值表示。

　　名称解析的深度优先搜索规则支持*词法作用域(lexical scoping)* 和*名称隐藏(name hiding)* 的实现。

　　求值 Unilang 表达式时总应存在一个环境，称为*当前环境(current environment)* ，作为名称解析算法的初始输入。

　　语言实现为程序开始运行时的具有的当前环境称为*初始环境(initial environment)* 。

　　部分名称是*保留名称(reserved name)* ：含有 `$$` 的名称保留给宿主交互使用；含有 `__` 的名称保留给语言实现。若程序的源代码中的保留名称被作为变量名解析，程序的行为未定义。

**注释** 隐藏环境作为父环境，可被名称解析利用，可以满足以其作为父环境的环境的稳定性。

## 间接值

　　引用值和环境引用统称*间接值(indirect value)* 。间接值关联和自身不同一的对象：引用值的被引用对象，和环境引用的环境对象。

　　间接值关联的对象通过间接值访问。

　　间接值有效当且仅当存在关联的对象且访问对象不引起未定义行为。其它间接值是无效的。

　　有效的引用值可能被*无效化(invalidate)* 。因关联的对象存储期结束而被无效化的是*悬空(dangling)* 间接值。

　　访问时，关联的对象的生存期未结束，否则非[内存安全](#内存安全)。

　　实现内部和派生实现可定义其它非引用值间接值。

## 合并子

　　*合并子(combiner)* 是在特定表达式中出现的可被求值时*调用(invoke)* 的对象。

　　合并子的调用接受*操作数(operand)* 实体。一般地，一个调用中的操作数作为一个对象，可具有树型结构，即*操作数树(operand tree)* 。

**注释** 典型地，操作数也可以指是一个操作数树的以子节点或连续的子节点序列表示的子对象。

　　合并子分为两类：

* 调用时总是先对操作数树中的每个直接子节点（若存在）求值，然后传递操作数的求值结果，调用对应的*底层(underlying)* 合并子。这种合并子是*应用合并子(applicative combiner)* 简称*应用子(applicative)* 。
	* **注释** 即操作数树是列表时的元素子对象。
* 否则，合并子是*操作合并子(operative combiner)* ，简称*操作子(operative)* 。

　　应用子的底层合并子可以是其它应用子。

**注释** 调用底层合并子是应用子的应用子时，可发生多次操作数的求值。

　　操作子调用匹配参数，可要求操作数符合一定的结构，否则参数不匹配。参数不匹配引起错误。

　　匹配参数后的操作子调用的具体行为由具体合并子对象确定。这可在创建合并子对象时决定。

　　合并子通过程序内的合并子的定义或其它另行指定的方式在外部引入。

　　在程序中定义的合并子提供指定*约束变量(bound variable)* 的*形式参数(formal parameter, parameter)* 和指定确定变量后的其它作用的*求值结构(evaluation structure)* 。

　　形式参数可以是符号、空列表或其它形式参数的列表构成的表达式树，统称为*形式参数树(formal parameter tree)* 。

**注释** 通过引用值构造的表达式树可共享被引用对象。此时，树是按其被引用对象的值取得的视图的表示。形式参数仍保持为有向无环图。

　　调用时，替换形式参数的值是实际参数(actual argument, argument) 。实际参数是传递给合并子的操作数。

**注释** 根据合并子是操作子或应用子，操作数或操作数的求值结果被作为实际参数。

　　一个存在形式参数的合并子被调用时，确定实际参数是否匹配形式参数树：确定实际参数和形式参数树中的对应位置的子表达式对应。若存在任一实际参数不对应，则参数不匹配。成功确定对应的形式参数树中的子表达式若为符号，则作为变量名，在特定的上下文中创建变量绑定，作为形式参数。绑定的实际参数和对应的形式参数作为不同的实体时，发生*参数传递(parameter passing)* 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。

　　一个存在求值结构的合并子被调用、所有的参数都匹配成功且参数传递成功后，（参数传递确定的）形式参数的值替换求值结构中的副本中和形式参数树的子表达式相同的符号。

　　合并子的*正常(normal)* 调用总是可确定一个计算结果，作为求值的结果。除非另行指定，若求值结果是引用值，则*提升(lift)* 为被引用对象的值。这避免返回*悬空引用(danling reference)* 。

　　合并子的*非正常(abnormal)* 调用不确保调用结果。

　　非正常调用的控制被转移到需要调用的求值表达式之外，这可以发生在引起错误时。

**注释** 关于合并子的形式理论，参见 [Shu10] 。

## 表达式语义

　　表达式符合的规则可能视使用的表达式，上下文相关。

### 求值算法

　　以被求值的表达式和所在的环境作为参数，基础语言使用以下统一的*求值算法(evaluation algorithm)* 取得表达式的*求值结果(evaluation result)* ：

1. *自求值(self-evaluation)* ：若被求值的表达式不是符号且不是有序对，则求值结果是自身。
2. 名称解析：若被求值的表达式是一个符号，则这个符号被视为*变量名(variable name)* ，求值结果是该符号在上下文（当前环境确定的词法作用域）中变量绑定确定的对象的经引用折叠的引用值。
3. 否则：
	**注释** 被求值的表达式是有序对。
	1. 若被求值的表达式是具有一个元素（子表达式）的列表，则求值结果是这个子表达式的求值结果。否则，继续以下求值步骤。
	**注释** 被求值的表达式是具有不少于一个元素的列表或非真列表。
	2. 若被求值的表达式第一个子表达式是空列表，则移除，并继续以下求值。
	**注释** 起始空列表的语法用于继续求值可能不提供[实际参数](合并子)的[函数合并表达式](#函数)。具有实际参数的函数合并表达式不一定需要起始空列表。
	3. 对第一个子表达式求值。
	4. 以第一个子表达式的求值结果作为*操作符(operator)* ，以其余子表达式作为操作数，求值*合并(combination)* 。

	有序对以外的表达式被求值时：

* 标识符的值是构成标识符的符号。
* 代码字面量的值是去除其边界的 `'` 的标识符构成的符号。
	**注释** 代码字面量可表达直接作为标识符时不能作为符号的词素的转义，例如 `''` 是一个空的符号；而 `'#ignore'` 和 `42` 这样的形式允许其中的表达作为变量名，而不是字面量。
* `#t` 和 `#f` 求值为自身，是布尔值(boolean value) 。
	* **注释** 布尔值只有这两种不同的取值。
* `#ignore` 和 `#inert` 求值为自身，具有和其它值不同的单元类型(unit type) 。
	* **注释** 单元类型只有一种不同的取值。
* 数值字面量求值为*数值(numerical value)* 。
	* **注释** 被支持的数值的范围详见以下标准库数值操作中关于数值类型的相关描述。

	非空列表和代码字面量以外的对象作为表达式，都是自求值表达式。

**注释** 空列表是值，而不一定需要是字面上的语法表示 `()` 。除源代码中的 `()` 的情形外，可能通过组合成带有空列表的表达式，使空列表在此被求值。

　　求值算法使用的环境是求值的*当前环境(current environment)* 。
　　
　　被作为操作符的值应是合并子右值或引用合并子对象的左值，求值合并的作用是调用对应的合并子；否则，求值失败，引起错误。

　　被求值的表达式的求值使用中缀变换和求值算法处理，实现求值。

**注释** 关于支持的中缀变换，详见以下相关小节。

　　一般地，求值蕴含值的计算和副作用。除非另行指定，子表达式的值的计算先序所在表达式的值的计算。

**注释** 求值合并中的子表达式可能不被求值。

　　此外，抽象机上（可能作为副作用和求值交互而影响可观察行为的）以下依赖关系：

* 一个对象存储的值依赖这个对象上的写操作。
* 访问一个对象取得值的读操作依赖这个对象存储的值。
* 派生实现定义的其它依赖。

　　为推理在求值时使用的值，以上依赖关系可被替换为[后序关系](#计算模型)。

**原理** 以上所有可推导出顺序的规则遵循*因果性(causality)* 。其它依赖可包括并发环境中的同步操作指定的依赖。当前实现不对此附加要求。

### 中缀变换

　　中缀变换的 `<transformed-infix>` 在被求值时在操作符的位置，起到函数的作用。

　　以下中缀记号中缀变换函数的调用具有以下语义：

* `;` 求值同标准库函数 `$sequence` 。
* `,` 求值同标准库函数 `list%` 。

### 函数

　　第一个表达式成功求值为操作子的列表表达式是*函数合并(function combination)* 表达式。在最终调用合并子的操作符位置的求值为合并子左值或右值的非列表表达式是*函数(function)* 。

　　函数是合并子右值、合并子左值（引用值）或求值为这些值的符号。

　　一般地，函数合并的求值结果替换函数合并表达式，这种替换是*函数调用(function call)* 。合并子调用的结果是函数调用的结果，称为*函数值(function value)* 。替换函数使操作数被求值的函数调用是*函数应用(function application)* 。

　　求值蕴含函数调用和函数应用的函数合并表达式分别是函数应用表达式和函数调用表达式，在不引起歧义时也简称函数应用和函数调用。

　　函数调用时，*主调函数(caller function)* 等*调用者(caller)* 或其它引起调用的计算的实体转移程序的控制到被调用的函数，使之*进入(enter)* 函数。控制可能通过调用被再次转移，即*嵌套调用(nested call)* 。一些被调用的过程可能被多次进入，即*重入(reenter)* 。

　　通过嵌套调用直接（总是以自身作为调用者）或间接（通过其它调用者转移控制）的重入是*递归调用(recursive call)* 。

　　特定的函数总是用来创建特定类型值的对象（右值）。这类函数是（特定类型值的）*构造器(constructor)* 。

### PTC(proper tail call)

　　求值函数调用时的最后一个函数调用是尾调用。尾调用发生在*尾上下文(tail context)* 。

**注释** 和某些其它语言不同，尾上下文是隐式的，由运行时的求值状态而非静态的语法构造确定。

　　若一个尾调用允许不限次数地重入，则尾调用是 PTC（Proper Tail Call，真尾调用）。

**注释** PTC 符合 [[Cl98]](https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf) 中 proper tail recursion 的形式定义。

　　支持 PTC 的尾上下文中被求值的子表达式中的对象生存期可被调整，其方式未指定。

**注释** 这不影响可观察行为，但可能要求和其它语言的互操作遵循附加的要求。

　　以下上下文提供 PTC 支持：

* 求值算法中的操作合并的求值。
* 以下标准库中的求值：
	* 对 `<body>` 的求值；
	* 由 `<test>` 控制或操作子中连续求值多个表达式中最后被求值的子表达式求值。
		* **注释** 这包括 `$if` 、`$sequence` 、`$and` 和 `$or` 的最后的参数（若存在）的求值。应用子对参数的求值明确非 PTC 。
	* 函数 `eval` 、`eval%`、 `id` 和 `idv` 的调用中蕴含的求值或替换。
		* **注释** 这不是作为参数的 <expression> 的求值。
	* 函数 `apply` 对 `<applicative>` 和 `<object>` 在 `<environment>` 或默认的动态环境中的应用。

　　不改变程序的可观察行为时，实现可支持任意其它的尾上下文上的 PTC 。

**原理** 缺乏核心语言特性支持下，难以通过库实现 PTC 保证。本质上，PTC 要求实现的结构在普遍配置下满足一定的空间复杂度要求，这不被基础语言（以及大部分其它现有编程语言）描述。使用库实现 PTC 要求反射并重写实现自身的结构，相当于重新实现具有 PTC 保证的新的语言；另一方面，从具有 PTC 保证的语言中通过库的特定操作消除 PTC（以允许资源清理和契约检查等操作占用尾调用的上下文）则相当容易。因此，PTC 保证原则上不适合通过库扩展，而应通过核心语言规则直接提供。

## 一等实体

　　程序引入或可被程序操作的 Unilang 实体在基础语言中是*一等实体(first-class entity)* 。一等实体总是可被作为操作数（用以调用函数）或作为函数调用的求值结果。

　　若一等实体是对象，它是*一等对象(first-class object)* 。

　　相较于其它语言，基础语言不附加限制区分非一等的实体。这有利于同时提升简单性和一致性。区分一等对象和一等实体并不是限制，

　　本文档和派生实现的语言规则可能引用其它的非一等对象。除非另行指定，不引入非一等对象。

　　在语言中可访问的环境一般是一等实体，即一等环境。语言也支持非一等的环境对象。访问非一等的环境对象时，它们不被环境对象的同一性影响，而是共享的。

**注释** 程序可在基础语言中指定不同的环境进行求值。但为可用性，环境的绑定和父环境这些状态都不是直接的一等实体。

　　临时对象非一等对象。

　　为灵活控制对象所有权，避免[循环引用](#引用值)且允许检查误用，一等环境可能对上述共享的资源实体具有所有权。大部分情况一等环境是共享环境状态的*弱引用(weak reference)* ，不具有所有权；其它情形一等环境对环境状态具有共享的所有权。

**注释** 综上，特定的对象非一等对象，如非一等的环境对象、临时对象和[子列表引用](#引用值)的被引用对象（子列表）。

## 实体表示

　　除非另行指定，实体的值使用以下规则定义的*外部表示(external represetntation)* ：

* 对列表，输出的表示是以 `(` 和 `)` 作为边界，元素以单个 ` ` 为分隔符的序列，其中的元素被递归地嵌套输出。
* 对非列表的存在对应字面量的值，输出这个值的字面量形式。
* 对引用值，输出被引用对象。
* 数值的外部表示由数值操作模块的规则约定。
* 其它值的外部表示未指定。

# 语言和程序接口约定

　　Unilang 实现环境应满足以上基础语言的语法和语义规则，并按以下的约定提供程序接口。

## 程序实现

　　语言实现外的程序是*用户程序(user program)* 。

　　以 Unilang 程序或派生语言实现指定的其它形式实现的可复用程序被归类为*库(library)* 。

　　语言特性包含不依赖库的*核心语言特性(core language feature)* 和*库特性(library feature)* 。本章之前的所有语言特性都是核心语言特性。

　　除非另行指定，一个 Unilang 程序支持多个库的实例，之间不共享内部的状态。

## 接口文法

　　实体元素使用以 `<>` 包含的格式。注意基础语言中仍可出现同名的标识符，但此处不按标识符解释。

　　操作数的子对象在操作的描述中作为约束，每个项以 `<>` 项表示，可以匹配其中的一个或者多个元素。

　　为区分同类约束的不同项，约束的名称后（在 `>` 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。

　　库可以和本节相容的形式引入文法，补充只在库中引用的操作数。除非另行指定，本节的要求适用于这些操作数。

### 元文法基本约定

　　描述语言规则和程序接口的元语言使用以下语法：

* `...` Kleene 星号，重复之前修饰的项 0 次或多次。
* `+` 重复之前修饰的项 1 次或多次。
* `?` 重复之前修饰的项 0 次或 1 次。

### 实体元素文法约定

　　求值得到的参数操作数约束隐含了操作接受的形式参数的值的类型。

　　指定具名的[函数](#函数)的文法中，第一项以符号的形式在所在的环境中提供，指定[求值结果](#求值算法)指称为合并子的函数名称。其后指定的文法中不同的元素对应合并子的操作数或其被作为调用时的形式参数树的子项。

　　操作数可能是左值或右值，视具体操作可被转换。

**注释** 另见[常规函数约定](#常规函数约定)、以下各节操作分类和具体操作的约定。

　　除[子类型](#类型)外，本节约定的不同类型的操作数构成的集合之间不相交。

　　除非另行指定，应用子操作数的约束也适用其[底层合并子](#合并子)。

　　根据是否可作为操作子中指定不被求值的函数参数，本节的操作数及其子项分为未求值的操作数和求值得到的操作数。前者也可能是表达式的求值结果。

　　未求值的操作数：

* `<symbol>` ：符号。
* `<symbols>` ：元素为 `<symbol>` 的列表，形式为 `(<symbol>...)` 。
* `<eformal>` ：表示可选提供的环境名称的 `<symbol>` 或 `#ignore`，或这些值的引用值。
	* 使用和 `<symbol>` 相同的表示。
	* **注释** 通常为动态环境。
* `<expression>` ：待求值的表达式。
* `<expressions>` ：形式为 `<expression>...` 的待求值形式。
	* 求值时被作为单一表达式，代替 `<expression>` 可避免语法中要求谁过多的括号及 `eval` 等求值形式中显式构造列表的需要。
* `<binding>` 绑定列表，形式为 `<symbol> <expressions>` ，用于指定被求值的表达式和绑定参数的符号。
* `<bindings>` ：元素为 `<binding>` 的列表，形式为 `(<binding>...)` 。
* `<body>`： 出现在元素的末尾 `<expressions>?` 形式，用于函数体等替换求值的目标。
* `<expression-sequence>` ：同 `<expression>...` 但蕴含顺序求值。
	* 求值 `<expression-sequence>` 的结果被定义为求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为 `#inert` 。
* `<consequent>` ：同 `<expression>` 仅用于 `<test>` 求值为 `#t` 时。
* `<alternate>` ：同 `<expression>` ，仅用于 `<test>` 求值不为 `#t` 时。
* `<ptree>` ：形式参数树，是包含符号或 `#ignore` 及其它形式参数树构成的有向无环图的表达式。
	* 语法要求由上下文无关文法描述：`<ptree> ::= <symbol> | #ignore | () | (<ptree>...)` 。
* `<definiend>` ：被绑定项的目标的 `<ptree>` 。
	* 引入绑定时，蕴含按绑定规则（参见以下具体绑定函数的描述）附加 `<ptree>` 以外的语义检查。
* `<formals>` ：作为形式参数的 `<ptree>` 。同 `<definiend>` 但允许派生实现定义更多检查。
* `<clauses>` ：元素为条件分支的列表，形式为 `(<test> <body>)...` 。
* `<variable>` ：变量。用于表示被定义的名称。同 `<symbol>` ，其中的处理与作为非列表的 `<formals>` 相同。

　　求值得到的操作数：

* `<object>` ：对象类型；一般对象，包括引用对象的引用值。
* `<reference>` ：对象引用值。
* `<list>` ：列表。
* `<lists>` ：元素都是列表的列表。
* `<pair>` ：有序对。
* `<boolean>` ：布尔值，值为 `#t` 或 `#f` 的集合。
* `<test>` ：类似 `<object>` ，通常预期为 `<boolean>` ，作为条件。当值非 `#f` 时条件成立。 
	* 若 `<test>` 求值为 `#f` ，则条件不成立。此时，若操作没有约定其它结果，则结果是 `#inert` 。
* `<combiner>` ：合并子。
* `<applicative>` ：应用子。
* `<operative>` ：操作子。
* `<predicate>` ：谓词，是应用操作数的求值结果的值为 `<test>` 的 `<applicative>` 。
* `<environment>` 一等环境。
* `<string>` ：字符串。
	* 字符串是包括数据字面量作为表示的值的类型。
	* 字符串的内部表示在具体实现中保持一致。除非另行指定，使用 ISO/IEC 10646 定义的 UCS 的 UTF-8 编码，其值不包含空字符（编码数值为 0 的 UCS 代码点）。
	* **注释** 为互操作的兼容性，一般建议实现使用兼容 [ISO C++] 中定义的 NTBS(null-terminated byte string) 的方式表达。
* `<parent>` ：指定环境的父环境的值，包括：
	* 环境引用：`<environment>` 或以 `<environment>` 值作为被引用对象的 `<reference>` 。
	* 元素为环境引用的 `<list>`
	* 以元素为环境引用的 `<list>` 作为被引用对象的 `<reference>` 。

　　文法元素补充约定：

* 除非另行指定，以 `<symbols>` 指定的值被作为 `<definiend>` 或 `<formals>` 使用时不引起错误。
	* **注释** `<symbols>` 在被其它上下文使用时仍可能引起错误。

## 类型检查

　　语言实现应具有语义规则指定的类型检查，以确保程序的执行符合操作的必要前置条件。

　　操作的语义可要求以下的类型检查：

* 对求值得到的操作数，按[文法约定](#接口文法)的约束进行类型检查。
* 根据特定对象状态，指定动态类型（如要求对象可修改）的检查。

　　实现可能添加其它不违反语义要求的类型检查。

　　类型检查失败时，引起错误，称为*类型错误(type error)* 。

## 安全性

　　不同操作提供不同的安全保证，确保满足特定条件的使用不会引入未定义行为。

　　访问不保证有效的[间接值](#间接值)的操作是不安全[间接值](#间接值)访问。

　　语言提供关于[内存安全](#内存安全)的基本保证：不存在引起[内存安全](#内存安全)以外的未定义行为的操作且不存在不安全间接值访问时，程序执行保证内存安全。

**注释** 互操作可能不满足以上保证。

### 保留间接值

　　对象的（直接或间接）子对象是间接值时，对象包含间接值。

　　修改对象为间接值或使之包含间接值时，对象保留间接值。

　　被保留的间接值是对应的通过修改得到或包含的间接值。

　　函数调用返回（在语言中允许出现的，下同）间接值或包含间接值的对象时，在函数值中保留间接值。

　　函数调用修改环境使[环境对象](#变量和环境)保留间接值（绑定间接值或包含间接值作为子对象的对象作为[被绑定对象](#变量和环境)）时，在环境中保留间接值。

　　函数调用修改一等对象或其子对象，使之保留间接值时，在对象中保留间接值。

　　在函数值中保留间接值、在环境中保留间接值、在对象中保留间接值的函数保留间接值。

　　被保留的间接值被函数调用的求值结果蕴含时，函数在结果中保留间接值。

**注释** 函数调用的求值结果即函数值。在结果中保留间接值包含以下情形：

* 在函数值中保留间接值。
* 在环境中保留间接值，环境是函数值或其子对象。
* 在对象中保留间接值，对象是函数值的子对象。

　　按被保留的间接值的来源，保留间接值分为以下两个子类：

* 直接保留间接值：接受间接值参数；
* 间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。

　　保留间接值作为返回值可能因间接值无效（如悬空引用）破坏内存安全。

　　保留环境的间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用（如引用值引用已不存在的关联环境导致访问环境中对象的未定义行为。

**注释** 引用值是一种间接值。因此，以上保留间接值的概念对应适用于间接值是引用值的情形。

## 子对象访问约定

　　作为使用[符号](#表达式的值和类型)访问对象的推广，特定操作可使用非环境的其它对象显式地访问其子对象。

　　此时，结果的值类别和类型由作为操作数的实际参数的值和具体操作的语义确定。

　　对操作 *F* 和实际参数 *E* ，以下规则确定访问操作的结果 *F E* 的值类别和类型：
　
* 若 *E* 不是环境，*F E* 来自 *E* 的子对象；否则，*F E* 来自 *E* 引用的环境的被绑定对象。
* *F E* 的类型经值类别转换后和 *E* 的子对象的类型相同。
* *F E* 的类型进一步按以下规则确定：
	若子对象是左值，则结果是左值。
	否则，若子对象是消亡值，则结果是消亡值。
	否则，若 *E* 是左值，则结果是左值。
	否则，*F E* 是消亡值。

　　和递归的[绑定匹配](#绑定匹配)规则类似，*E* 或被访问的子对象的[不可修改标签](#对象的其它元数据)被传播：若具有不可修改标签，结果也具有不可修改标签。

　　除非另行指定，被访问的子对象访问若具有影响值类别或被传播以外的其它标签，则标签被保留：对应在结果中出现。

　　其次，具体操作可能具有其它改变结果的值类别和类型的约定，上述结果中的左值和消亡值可被替换为右值。

# 基础语言实现环境

　　Unilang 以环境的绑定作为公开的接口提供库特性。

## 基础求值环境

　　基础语言提供一个*基础环境(ground environment)* ，其中蕴含的变量绑定（包括包含的变量绑定和可能通过环境子对象提供的变量绑定）提供上述的主要的特性，作为程序应用程序的编程接口，也是语言扩展和应用程序的可编程性的基础。基础环境应包含语言规范要求提供的所有绑定，且不包含名称除保留名称外的绑定。

　　基础语言的用户程序初始的当前环境是一个包含基础环境作为直接或间接父环境的空环境。基础环境在此是[隐藏环境](#隐藏环境)，应能确保程序执行时[不改变基础环境中的绑定](#冻结)。

**注释** 为此，基础环境自身不是以一等环境提供的库特性，而是核心语言特性。

　　实现在用户程序初始的当前环境中按本文档指定的方式继续提供绑定，以便简化公共实现。

　　基础环境的绑定提供的特性有两类：对象和*操作(operation)* 。应被支持的操作以具有明确名称的函数进行指定，参见以下章节。

　　在环境中定义另一个环境中的同名变量，使被定义的变量是后者的引用值或值的副本，则称指定此变量名的符号在后者被*导入(import)* 前者。

**注释** 用户程序可导入环境中的符号使用库中的绑定。

## 库特性分类

　　库特性按分为*基本的(primitive)* 和*派生的(derived)* 。前者在设计上不分解为更小的其它特性的组合；后者可由基础语言代码实现。本文档中不明确指定派生的特性是否使用以基础语言源程序进行派生的形式实现。

　　本文档中约定的在基础环境中的特性中，以库提供的总称为*标准库(standard library)* 。本文档中的库特性都是标准库特性。

## 模块

　　以绑定提供的语言特性被分组归类为*模块(module)* 。

　　模块的*源(source)* 提供特性的实现。

　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为子对象的其它对象中。

　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的*加载(loading)* 。

　　模块加载可能失败。失败的模块加载引起错误。

　　标准库模块的加载失败不被直接依赖这些环境的用户程序处理（而视为实现初始化的运行时错误）。

　　一般地，模块和加载模块得到的环境对象没有直接对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。

　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。

　　标准库包括以下模块：

* 标准库基本对象和操作。
* *核心库(core library)* ：提供直接绑定在基础环境中的派生操作的标准库子集。
* 标准库扩展模块：在标准库中提供环境的绑定，并在其中提供库的接口。
* 在基础环境中提供的辅助库接口。

**注释** 辅助库接口在当前标准库内未归类，可能迁移或移除。

　　除绑定可能在不同环境直接提供外，不同模块的边界不被要求在基础语言的实现中区分。

　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。

　　以下各节的约定对标准库函数有效，用户程序不被要求。

### 加载和使用标准库模块

　　求值环境的初始化蕴含模块初始化。

**注释** 可访问不作为公开接口提供的模块的源。

　　派生实现可同时以标准库以外形式提供这些源为公开接口，用户程序也可显式地加载这些源对应的模块。

　　除非另行指定：

* 若这些源可能引起引入非公开的接口的副作用，则对应的模块不应被用户程序直接加载。
* 假定加载这些模块时，当前环境是和标准环境或与其等价的其它环境。
	* 其中，等价指使用其它环境不引入程序可观察行为差异。
	* **注释** 等价的环境的例子包括以标准环境为父环境的空环境，以及这样的空环境导入符号的得到的结果。
	* **注释** 若模块的加载不访问加载时初始的当前环境（通常仅在本机模块上适用），加载模块使用的环境可不影响可观察行为而不影响假定（即便和标准环境不等价）。
* 违反以上要求或假定的程序行为未定义。
* **原理**
	* 以源程序模块实现时，一般不要求检查初始环境。这能有效减少实现的复杂性。
	* 因为标准环境不提供用户程序检查是否和其中定义的实体一致的直接的方法，通过 `eq?` 等替代的检查可能排除符合假定的初始环境。
* **注释**
	* 这里的初始化可包含派生实现定义的其它初始化。
	* 虽然标准库不作为接口保证提供这些源，这里的假定和 [ISO C++] [using.headers] 对引入标准库头的程序位置的限制类似：语言实现能有效地假定源程序中引入标准库头的上下文，因此标准库中的名称具有预期的含义。

### 模块稳定性

　　提供模块绑定的环境依赖已知来源的绑定而确保[稳定](#稳定性) 。

　　对标准库模块，这一般表示其中的特性不能依赖用户程序运行时的非特定的当前环境，而可依赖从[基础环境](#基础求值环境)及从基础环境派生的新环境。

　　除非另行指定，模块中的特性依赖提供模块绑定的环境的[生存期](#对象的存储期和生存期)。

　　除非另行指定，标准库实现应确保其中的模块在程序的生存期中可用。这一般要求标准库实现在初始化后保存[环境强引用](#变量和环境)。

　　用户程序应自行保证加载的其它模块具有足够的生存期，以避免访问悬空引用导致的未定义行为，特别是使用在环境中[保留引用值](#保留引用值)的操作的情形。

## 函数的间接值使用

　　作为接口的安全保证机制，标准库函数满足本节规则。

### 作为实际参数

　　除非另行指定，一般地，函数接受左值引用操作数，使用引用的对象的值和直接使用右值作用相同，但不会修改被左值引用的对象。

　　这等价隐含无副作用的[左值到右值转换](#引用值的访问)。

### 作为函数值

　　部分操作地结果总是非引用值，以满足具体操作的语义要求。这些操作对应的函数调用返回非引用值。

　　返回非引用值的行为应等价[返回值转换](#返回值转换)。

　　其它操作可具有引用值结果，对应的函数调用可返回引用值。

### 保留引用值

　　[保留间接值](#保留间接值)，包括直接保留间接值和间接保留间接值，适用间接值是引用值的情形，对应地称为保留引用值、直接保留引用值和间接保留引用值。

　　除非另行指定，被保留的引用值不被折叠。

**注释** 通过要求引用折叠，可避免引入非预期的引用的引用值。

　　函数是否保留引用值以及保留引用值是否被折叠的要求，参见[常规函数约定](#常规函数约定)和[函数名称约定](#函数名称约定)。

　　除非另行指定，考虑[内存安全](#安全性)时，因无法保证如引用值通过关联的环境追溯被引用对象类似的机制可用，环境引用外的[非引用值间接值](#间接值)视为不具有[内存安全保证](#安全性) 。

　　[间接保留引用值](#保留间接值)可包含部分直接[转发](#操作数约定)引用值的情形。包含这种情形的操作不因此被视为直接保留引用值，即便部分引用通过直接转发引用值被保留。这保证以上两个子类不相交。

　　[直接保留引用值](#保留间接值)覆盖常规函数约定的实际参数约定，指定参数不隐含[左值到右值转换](#引用值的访问)，可按引用值直接访问。

### 保留环境引用

　　保留间接值适用[环境引用](变量和环境)。

**注释** 因为只允许通过环境引用访问环境对象及其子对象，访问环境但不保留环境引用的操作只可能在（不保证内存安全的）互操作中出现。

## 函数参数和函数值传递约定

　　函数可能接受[引用值参数](#作为实际参数)和[返回引用值](#作为函数值)，是对函数的形式参数或函数值的[初始化](#初始化)。

　　在复制初始化形式参数和函数值时，部分函数保证被初始化的值和[初值符](#初始化)的值类别和可修改性一致。这些初始化是*转发(forward)* 操作。

### 传递非引用值参数

　　一些函数的参数进行[左值到右值转换](#引用值的访问) 。

**注释** 这类似 [ISO C++] 中直接使用对象类型的形式参数。

### 函数参数转发

　　一些求值为引用值的函数实际参数被保留，而不进行[左值到右值转换](#引用值的访问)。这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被*转发(forward)* 。

**注释**

* 参数转发类似 [ISO C++] 的 `auto&&` 推导的参数值的转发。
* 参数转发的实现可判断值类别后分别对传递非引用值或直接传递引用值提供实现，或直接使用[绑定构造](#绑定操作)。

### 返回非引用值

　　返回非引用值和传递非引用值参数类似：若初始化函数值的初值符是引用，复制或转移被引用对象的值而不是引用值。

**注释** 这类似 [ISO C++] 中返回 `auto` 类型。

　　若初始化函数的初值符经过至多一次[折叠](#引用值和初始化)即可[消除引用值](#引用值的消除)，返回非引用值保证函数值总是非引用值。

### 函数值转发

　　一些其它保留引用值的操作中，引用值来自参数，且难以通过自身的逻辑单独决定可否安全地直接返回引用值。

　　此时，在返回之前根据特定参数是否为引用值，可选地转换结果以确定是否保留引用值，即进行转发。

　　特定的显式转发操作转发临时对象的引用值使临时对象被转移，以转发的值作为结果，可不同于使用返回值转换：

* 同返回值转换，转发转移右值，复制左值。
* 但当转发临时对象可确定唯一使用时，也转移临时对象。

**注释**

* 确定是否保留引用值的机制类似 ISO C++14 中从没有括号的 *id-expression* 上推断返回 `decltype(auto)` 类型是否为引用类型。
* 另见[对象的可转移条件](#对象的可转移条件)。
* 显式转发操作把右值、消亡值和带有临时对象标签的左值引用视为被转发的目标。
* 转发列表对象的子对象可能转移这个对象。

### 创建和访问对象的函数

　　[构造器](#函数)是用于创建对象的函数。

　　除非显式指定创建的对象具有引用值类型，构造器[返回非引用值](#返回非引用值)。

　　部分操作涉及对其它对象具有所有权的对象。

　　一部分对象的构造器创建的对象完全通过其它对象的引用或对象的值作为构造器的参数而决定，且创建的对象对这些参数具有所有权，这样的对象称为*容器(container)* 。

　　容器构造器的参数作为容器的子对象，是容器的*元素(element)* 。

**注释** 这扩展了[有序对和列表](#表达式的值和类型)的元素的概念。

　　以容器对象或其引用作为参数，取得容器元素对象或其引用的函数是容器*元素访问器(accessor)* 。

　　标准库提供一些属于构造器和访问器的操作。除非另行指定，标准库的访问器符合[子对象访问约定](#子对象访问约定) 。

## 常规函数约定

　　提供操作的函数满足以下常规函数约定：

* 除非另行指定，操作以指定名称的变量的形式提供，求值为可参与函数合并的一等对象。
* 除非另行指定，函数作为表达式，求值为合并子，其函数合并的求值蕴含函数调用。
* 除非另行指定，本文档约定的函数在其调用不依赖用户程序提供的可能不终止的函数时，总是可终止。

**注释** 另见以下关于操作的分类和具体操作的约定。

　　对函数值具有以下常规函数约定：

* 除非另行指定，函数值不是引用值。
* 除非另行指定，函数不在函数值中[保留引用值](#操作结果约定) ，即函数值经过[返回值转换](#返回值转换)。
	* **注释** 保留引用值时，函数值仍可能是非引用值。
* 除非另行指定，若函数值保留引用值，引用值被折叠。

　　对实际参数具有以下常规函数约定：

* 除非另行指定，函数的实际参数的传递不具有影响可观察行为的作用。
	* **注释** 这一般要求避免实现复制时具有副作用的内部对象。
* 除非另行指定，函数的实际参数若被求值，隐含左值到右值转换。

　　对错误处理具有以下常规函数约定：

* 除非另行指定，若函数合并指定的操作的约束或要求检查的条件不被满足，引起错误。
* 除非另行指定，引起错误抛出[异常](#诊断)。
* 求值时引起的错误使求值中断可产生副作用，这样的副作用总是[后序](#计算模型)于已被求值的表达式中产生的副作用。
* 被错误处理和检查的函数不修改参数或者函数调用外创建的对象。

## 操作类型约定

　　*谓词(predicate)* 是结果类型为 `<boolean>` 的函数。

　　除非另行指定，以下引入的谓词调用时没有副作用。

　　标准库约定以下典型的谓词：

* *类型谓词(type predicate)* ：接受一个 `<object>` 参数，判断参数是特定的类型的对象。
	* 调用这些类型谓词不引起错误。
	* 仅当参数指定的对象具有对应类型时结果是 `#t` 。
	* 除非另行指定，这些类型谓词忽略值类别的差异。
* *等价谓词(equivalence predicate)* ：接受两个参数，判断参数是否属于同一个等价类。

**注释** 返回的 `<boolean>` 值可在要求 `<test>` 的上下文中使用。

## 函数名称约定

　　对应合并子是操作子的函数以 `$` 起始。

　　作为谓词的函数名以 `?` 结尾。

　　为改变对象而直接（而不是通过指定参数求值）蕴含副作用函数名以 `!` 结尾。

　　若函数提供结果无条件保留引用值和不保留引用值的不同版本且保留引用值的函数是不安全函数，保留引用值的函数名以 `%` 作为（在可能的 `!` 之前的）后缀。

**原理** 关于 `$`、`?` 和 `!` 的原理，参见 [RnRK] 1.3.7 。

## 不安全操作

　　不安全(unsafe) 操作是可能在程序的执行中引入未定义行为的操作。

　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。

　　不安全操作是实现可选提供的。这些操作可能因不同理由在操作中或操作之后的程序中引入未定义行为：

* 保留可能无效的间接值：
	* 保留可能无效的引用值（如[悬空引用](#中间值)）。
	* 保留可能无效的环境引用。
* 可能因为操作环境强引用而引入循环引用。
* 可能引入数据竞争。
* 是其它另行指定的可能引入未定义行为的操作。

**注释** 当前语言不支持并发访问对象。数据竞争仅可由和宿主语言的互操作引入。

　　通过避免或限制使用具体的不安全操作，可实现上述安全保证。

　　除非另行指定，执行时包含以下操作的操作是不安全操作：

* 以下不具有[内存安全](#安全性)保证的操作：
	以下相关章节按[操作名称约定](#操作名称约定)的保留引用值的操作。
	其它保留间接值的操作。
* 以下可能引入[循环引用](#引用值)的操作：
	引入引用现有环境的环境强引用的操作。
* 其它另行指定的操作。

**注释** 互操作可包含和以上操作等效的不安全操作。

## 操作结果约定

　　若以下关于操作的描述中未指定调用的求值结果，则结果是右值 `#inert` 。

　　除非另行指定，没有明确在操作结果中保留引用值的其它一些操作的结果进行[返回值转换](#引用值和初始化)：一次引用值提升转换和可选的临时对象实质化转换的复合。

　　除非另行指定，函数的实际参数的[传递](#合并子)不具有影响[可观察行为](#计算模型)的作用。

**注释** 这一般要求避免复制实现中可在复制时引起副作用的对象。

　　除非另行指定，函数的实际参数若被求值，隐含左值到右值转换。

　　若函数是用于返回非引用值的*构造器(constructor)* ，则可能提供不同的变体：

* 实际参数发生左值到右值转换。这减少悬空引用的可能性。
* 实际参数不发生左值到右值转换。这是不安全操作，但可以确保构造的对象中包含参数指定的引用值。

### 保留引用值的操作子

　　部分函数是选取特定实际参数求值用以确定结果的操作子。这类操作子结果直接是求值的参数，保留引用值而不进一步转换。

## 操作副作用约定

　　部分操作可能修改参数指定或关联的对象。修改的对象一般通过引用值指定。若被修改的对象以[子对象引用](#引用值)访问，则不保证修改总是共享到它的被引用对象。

## 绑定操作

　　部分操作作为引入变量绑定，这些操作是绑定操作。绑定操作引入变量可能修改环境。

　　绑定操作决定符号或具有符号的数据结构与[操作数树](#合并子)中的项的对应关系，并[初始化](#初始化)被绑定对象。

　　绑定操作在源代码中的语法是*绑定构造(binding construct)* 。绑定构造包含形式参数树。

　　为决定形式参数和操作数的对应，比较形式参数和操作数树或其子对象的结构，即*绑定匹配(match)* 。

　　被匹配的操作数是操作数树作为[有序对](#表达式的值和类型)的元素。类似地，形式参数是形式参数树作为有序对的元素。

　　形式参数树具有特定的语法规则描述其结构要求。若不符合语法规则，则引起错误，不进行绑定。

**注释** 参见 `<ptree>` 的定义；形式参数树的节点可以是符号的引用值，但不支持多重引用。

　　一般地，形式参数树决定被绑定的变量的名称，形式参数树中的符号作为变量名，经绑定匹配决定对应的被绑定对象。若匹配失败，则引起错误。

　　成功的匹配决定形式参数对应的操作数或其子项，作为其实际参数。这种对应关系是单射但不一定是满射，即匹配成功后，每个参数总存在对应的操作数或其子项，而操作数和子项允许不对应形式参数而被忽略。

**注释** 绑定构造具有函数合并的形式，操作数或子项总是能作为函数的实际参数。

### 绑定初始化

　　创建绑定时形式参数对应的变量在对应的符号的绑定匹配之后被操作数复制初始化：

　　绑定初始化不修改形式参数，但可能因初始化转移初值符而修改操作数。

　　绑定前不对形式参数或实际参数中的元素求值。

　　除非另行指定，不同变量的绑定初始化之间非决定性有序。

### 绑定临时对象

　　[绑定初始化](#绑定初始化)的被引用对象可能是临时对象。

　　绑定构造中不同变量的不同绑定方式指定特定的操作数或子项被绑定为临时对象。一般地，仅纯右值实际参数可被绑定为临时对象。

**注释** 参见以下对引用标记字符的描述。

### 绑定匹配

　　绑定匹配以一个形式参数树和操作数树作为输入，比较两者的结构并尝试关联形式参数树中的子项到操作数蕴含的对象，以创建变量绑定。

　　若绑定匹配成功，则可能进行符号为名称的对应变量的[绑定初始化](#绑定初始化)；否则，绑定匹配失败，引起错误。

　　绑定匹配确定每一个符号的过程先序这个符号确定的变量的绑定初始化。

　　绑定匹配不修改形式参数，在匹配成功进行绑定初始化前不修改操作数。

　　使用如下算法搜索形式参数树和操作数的对应位置进行匹配：

* 初始化输入的形式参数树为当前形式参数，函数合并作为当前操作数。
* 对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配被引用对象，下同）：
	* 若两者都是有序对，则：
		* 若形式参数有序对元素的结尾元素不是符号也不是有序对，则参数匹配失败。
		* 若形式参数是列表，且元素的结尾元素是以 `.` 起始的符号，则存在*省略(ellipsis)* ；保存移除 `.` 的符号，并从子项中移除结尾元素，继续进行比较。
		* 若形式参数和操作数的（直接）子节点数（作为实际参数时的列表元素数）相等，或存在省略时移除结尾元素后的形式参数元素数不大于操作数子节点的元素数，则：
			* 忽略形式参数中的省略的元素，以深度优先搜索从左到右逐一递归匹配两者的元素。
			* 若存在省略的元素，若保存移除 `.` 的符号非空，以移除 . 的符号作为形式参数，匹配操作数构成的*结尾序列(trailing sequence)* 。
			* 否则，若形式参数是非列表的有序对（最后的元素非空），匹配结尾序列。
			* 否则，若所在的形式参数列表的结尾元素是 `.` ，参数匹配成功，忽略结尾序列，不绑定对象。
			* 否则，没有其余元素需要匹配，参数匹配成功。
				**注释** 先前对形式参数和操作数的节点数判断同时确保结尾序列为空。
			* 匹配结尾序列的规则参见[非递归绑定](#非递归绑定) 。
				**注释** 结尾序列预期匹配的操作数是空列表或有序对。对操作数是列表的情形，结尾序列是结尾列表(trailing list) 。
		* 否则，若不存在省略，列表的元素数不相等，参数匹配失败。
		* 否则，操作数的子节点不足，参数匹配失败。
	* 若形式参数是空列表，则：
		* 若实际参数不是空列表，则参数匹配失败。
		* 否则，参数匹配成功。
	* 若形式参数是引用值且没有因为本条匹配规则递归进入匹配，则以其被绑定对象代替当前形式参数递归匹配。
	* 若形式参数不是符号，则参数匹配失败。
	* 若形式参数是不等于 `#ignore` 的符号，则尝试绑定操作数到以符号确定的名称的形式参数。
		* 若符号以一个*标记字符(sigil)* 起始，则被绑定的变量名中去除此前缀。
		* 若去除前缀得到的符号为空，则忽略操作数，不绑定对象。

　　绑定匹配时不检查重复符号。若形式参数树中出现重复的符号，可被多次匹配成功。这可导致之后的绑定初始化中，只有其中某个未指定的绑定生效，其它绑定被覆盖。

**注释**

* 函数合并构成的操作数树包括作为合并子的第一个子项和作为操作数的之后余下的子项。
* 列表外的 `.` 起始的词素视为普通的符号。
* 被忽略的绑定不保存绑定的对象。
* 不在列表内最后位置的带有前缀 . 的形式参数绑定的是普通的变量，不忽略绑定。
* 其它一些不支持有序对的语言，如 ECMAScript 2019 的 `rest` 参数支持类似结尾列表的效果。
* 绑定匹配和创建绑定的初始化之间的顺序约定是必要的，因为这里约定的是一般的作用之间的顺序而非子表达式的求值之间的顺序，求值算法中的默认规则不适用。
* 绑定匹配允许并行实现。

### 引用标记字符

　　应用在形式参数树符号的前缀 `%` 、`&` 或 `@` 为标记字符表示名称绑定的可按需引入引用，称为引用标记字符。

　　绑定引用时，可使用引用推断规则：引用值按值传递给形式参数，非引用值按引用传递给形式参数；否则，操作数按值传递给形式参数。

　　标记字符影响引用相关的绑定，差异为：

* 没有标记字符生效时，对操作数按值绑定，实际参数值传递给对应的形式参数。
	* 若实际参数的值是泛左值，则实际参数上首先隐含左值到右值转换。
* 存在标记字符 `%` 或 `&` 时，按引用推断规则直接绑定或转发操作数。
	* 当实际参数是引用值时，在根据以下规则确定被绑定对象时，隐含一次[引用折叠](#引用值和初始化)。
* 存在标记字符 `@` 时，绑定以实际参数作为被引用对象的引用值，不论操作数的类型和值类别。
	* 初始化引用值时，没有[引用值的消除](#引用值和初始化)。

### 非递归绑定

　　非递归绑定在一次匹配之后创建对应的变量绑定。

　　合并使用或不使用[引用标记字符](#引用标记字符)的情形，[非结尾序列](#绑定匹配)的单一参数对象的[绑定初始化](#绑定初始化)包含以下过程：

* 若不存在绑定标记字符 `@` ，则：
	* 若操作数为可转移的对象的引用值，则被绑定对象是按以下规则初始化的蕴含隐含的引用折叠的引用值：
		* 存在标记字符时，使用引用推断规则，被绑定对象是操作数直接初始化的值，其中被绑定对象（引用值）的标签由操作数的（引用值）的标签决定：
			* 当有标记字符 `&` 、绑定非结尾列表且引用值的标签指定唯一引用时，被绑定对象（引用值）中包含绑定临时对象标签。
				* **注释** 使用 `%` 可避免操作数中的唯一引用标签在被绑定对象中蕴含临时对象标签的行为。
			* 否则，被绑定对象的标签和引用值的标签相同。
		* 否则，被绑定对象是操作数复制初始化（复制或转移）的值。
	* 否则，若操作数标签指定可修改的唯一引用或有标记字符 `%` 时的唯一引用，操作数是可转移的非引用值，被绑定的对象是临时对象。
	* 否则，当存在标记字符 `&` 时，被绑定对象是操作数的引用值。
		* **注释** 此处的被绑定对象可在[作为符号求值](#求值算法)时被折叠并在结果中进一步去除可能具有的唯一引用的标签。
	* 否则，被绑定对象是复制自操作数的值。
* 否则，被绑定的是操作数的引用：
	* 绑定操作数的引用时，要求引用的是列表中的项，否则抛出异常。
	* 被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。

　　绑定[结尾序列](#绑定匹配)包含以下情形：

* 若不存在标记字符 `@` ，则：
	* 若操作数为可转移的对象的引用值，按非结尾序列的规则绑定操作数。
	* 否则，若操作数标签指定可修改的临时值或有标记字符 `%` 时的临时值，按非结尾序列的规则绑定操作数。
	* 否则，创建新的有序对，并在其中相应的绑定其元素子对象。
* 否则，创建新的有序对，在其中以标记字符 `@` 绑定元素子对象。

　　绑定结尾列表若创建列表（包括[子对象引用](#引用值)隐含创建的共享列表对象），其中的子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。

　　绑定结尾序列创建新的有序对并绑定元素子对象时，作为列表[完全分解](#表达式的值和类型)得到的每个元素组合的列表，满足：

* 若操作数是临时对象，则操作数子项在绑定元素子对象时被复制消除(#复制消除) 。
* 组合的列表是[非真列表](#表达式的值和类型)，当且仅当操作数是非真列表。
* 子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。
	* **注释** 若不存在引用标记字符，元素被对应复制初始化。
* 若操作数是非真列表：
	* **注释** 即需初始化组合中非空的值数据成员。
	* 当不存在标记字符或存在标记字符 % 时，组合的最后一个元素是操作数中的最后一个元素的副本。
	* 否则，组合中的最后一个元素是新创建的子对象引用。
		* **注释** 同一般的引用值，不对被引用对象具有所有权。
	* 创建的有序对初始化完成后，参与初始化被绑定对象：
		* 若存在标记字符 `&` ，则创建子对象引用作为被绑定对象，其被引用对象是创建的有序对。
			*被创建的子对象引用的被引用对象的表示应避免复制初始化任何操作数一等对象。
		* 否则，创建的有序对直接被作为被绑定对象。
			* 若存在标记字符，同时视为[绑定临时对象](#绑定临时对象) ，设置[临时对象标签](#对象的其它元数据)。

　　除[绑定临时对象](#绑定临时对象)外，若绑定操作数的初始化的引用值时实际引用临时对象，则行为未定义。

　　仅在绑定临时对象到引用时使用复制消除。

**注释**

* 不和 [ISO C++] 一样可能延长右值类类型子对象的生存期。
* 具有引用标记字符的形式参数支持引入引用值并支持绑定引入临时对象的[实际参数](#合并子) 。

# 标准库接口

　　本章指定标准库提供的具体程序接口。

## 标准库对象

　　标准库的对象在基础环境中直接提供绑定。

　　标准库提供对象 `ignore` ，其值为 `#ignore` ，在特定操作中表示被忽略的值。

## 标准库基本操作

　　标准库基本操作在基础环境中直接提供绑定。

`eq? <object1> <object2>`

　　判断引用相等关系。当且仅当对象同一时引用相等，结果是 `#t` ，否则为 `#f` 。

`eql? <object1> <object2>`

　　判断对象表示的叶节点值相等关系。其中，叶节点指枝节点表示（参见 `branch?` ）以外的表示。

　　对具有枝节点的表示，这等价以 `eqv?` 比较忽略构成枝节点表示的子对象：

* 若参数是引用值或最后一个元素为引用值的[非真列表](#表达式的值和类型)，则使用引用值的被引用对象代替参数继续进行以下比较。
* 若两个参数都是列表，结果为 `#t` 。
* 否则，若参数中一个是[列表](#表达式的值和类型)值而另一个不是列表值，则结果为 `#f` 。
* 否则，两个参数都是[非真列表](#表达式的值和类型)值，结果等价[完全分解](#表达式的值和类型)的最后一个元素之间 `eqv?` 比较结果。

`eqv? <object1> <object2>`

　　判断非列表的值相等关系。当且对象转换的右值相等时，结果是 `#t` ，否则为 `#f` 。

　　`eqv?` 确定的相等关系的比较结果应满足：

* 当两个参数中至少之一不是有序对，同 `eq?` 的比较结果。
* 若两个参数的内部表示相同，则结果是 `#t` 。
* 若两个参数的 `eqv?` 比较结果是 `#f` ，则这两个参数以 `eq?` 比较结果总是 `#f` 。
* 不等价的函数的 `eqv?` 比较结果是 `#f` 。
	* 这里的等价关系定义为：仅当一个函数或其作为子表达式的任意表达式和对应把这个函数替换为另一个函数的表达式的求值的可观察行为总是相同，则两个函数等价。

`$if <test> <consequent> <alternate>`

　　条件分支，按条件成立与否返回 `<consequent>` 或 `<alternative>` 之一，可能是引用值。

`$if <test> <consequent>`

　　省略第三操作数的条件分支，条件成立时返回 `<consequent>` 。

`null? <object>`

　　判断操作数是否为空列表。

`branch? <object>`

　　判断操作数是否具有枝节点表示。非空列表和其它由派生实现定义的数据的内部表示具有枝节点表示。

`pair? <object>`

　　`<pair>` 的[类型谓词](#操作类型约定)。

`list? <object>`

　　`<list>` 的类型谓词。

`reference? <object>`

　　判断操作数是否为引用值。

`unique? <object>`

　　判断操作数是否为唯一引用。

`modifiable? <object>`

　　判断操作数是否为可修改对象或可修改对象的引用值。

`bound-lvalue? <object>`

　　判断操作数是否为被引用的被绑定对象左值。

**注释** 绑定临时对象的引用类型的参数不被视为左值引用。

`uncollapsed? <object>`

　　判断操作数是否为未折叠的引用值。

`as-const <object>`

　　取指定对象的不可修改的引用。

　　当参数是引用值时，结果是和参数引用相同对象的不可修改的引用值；否则，结果是参数。

`expire <object>`

　　取指定对象的唯一引用。

　　当参数是引用值时，结果是和参数引用相同对象的唯一引用值；否则，结果是参数。

`move! <object>`

　　转移对象。

　　若参数是不可修改的左值，则以复制代替转移；否则，直接转移参数对象。

　　结果不经[返回值转换](#引用值和初始化)。

`assign@! <reference> <object>`

　　赋值被引用的对象为指定对象的值，且 `<object>` 不隐含左值到右值转换且不被折叠。

　　检查 `<reference>` 是可修改的左值。

　　赋值对象直接修改被引用的对象，但不无效化参数指定的引用。

`cons <object1> <object2>`

　　构造参数指定的两个元素构成的有序对。

　　结果是 `<pair>` 类型的值。

**注释** 不保留 `<object2>` 的引用值，但这不涉及 `<object2>` 是有序对或有序对的引用值时其中可能具有的元素。若 `<object2>` 中存在元素，直接被作为结果的元素，不经过返回值转换。

`cons% <object1> <object2>`

　　构造参数指定的两个元素构成的有序对，保留引用值。

　　同 `cons` ，但参数是引用值时，直接以其值作为元素的值，而不以其被引用对象的值创建有序对。

**注释** 这允许被构造的结果中存在和参数相等的引用值，而非其被引用对象的副本。

`desigil <symbol>`

　　移除符号中的引用标记字符 `&` 或 `%` 。

　　判断符号非空且以 `&` 或 `%` 起始，结果是移除起始字符的参数。否则，结果是参数。

　　不处理引用标记字符 `@` 。

`eval <expression> <environment>`

　　在参数指定的环境中求值，结果作为函数值。

`eval% <expression> <environment>`

　　同 `eval` ，但保留引用值。

`bound? <string>`

　　判断指定字符串对应的符号是否被绑定。

`$resolve-identifier <symbol>`

　　解析标识符。

　　直接保留解析结果中项的类型，不按成员访问规则确定值类别，因此和解析名称表达式的结果总是左值不同，可保留消亡值。

`$move-resolved! <symbol>`

　　转移解析标识符的对象。

　　和 `$resolve-identifier` 类似，但直接取被绑定的对象并从环境中转移。

**注释** 一般应仅用于被绑定的对象不需要再被使用时。

`lock-environment <environment>`

　　锁定环境：创建环境强引用。

　　检查操作数的环境弱引用，结果是对应的环境强引用。

**注释** 强引用可能引起环境之间的不被检查的[循环引用](#引用值)，用户应自行避免未定义行为。

`make-environment <environment>...`

　　创建以参数为父环境的环境。

　　创建的环境是强引用。

`weaken-environment <environment>`

　　使用环境强引用创建环境弱引用。

　　检查参数类型是环境强引用，若失败则引起类型错误。

`$def! <definiend> <expressions>`

　　修改当前环境中的绑定。

　　类似 <formals> ，<definiend> 支持递归匹配。

`$vau/e <parent> <formals> <eformal> <body>`

　　创建指定静态环境的 vau 抽象。

**原理** 关于 vau 抽象，参见 [Shu10] 。[RnRK] 提供和本文档中的 vau 抽象构造器类似的操作，但不包含 `<parent>` 的支持。

　　创建的抽象是操作子，作为求值 `$vau/e` 的调用结果。

　　求值 `$vau/e` 的调用首先求值 `<parent>` ，其结果中的环境是创建的抽象的*静态环境(static environment)* 。

　　`<formals>` 是指定*形式参数(formal parameter)* 表达式，应为以符号为非分支节点的有向无环图。由于不支持引用值，实际上是树，非分支节点是树的叶节点，分支节点是列表。

　　`<eformal>` 是指定*动态环境(dynamic environment)* 的表达式，应为符号。动态环境是发生调用处的当前环境。

　　`<formals>` 被用于在合并子调用时匹配操作数树而引入变量绑定作为形式参数。其中，参数匹配算法是以 `<formals>` 作为输入参数树的绑定匹配算法。

　　创建的抽象作为操作子，被调用时：

* 保存当前环境作为动态环境。
* 创建环境*守卫(guard)* 保存当前环境，之后不论调用成功或出错都会回滚保存的环境。
* 创建新的环境，并以这个新环境作为当前环境。
* 若创建抽象时的 `<eformal>` 是不等于 `#ignore` 的符号则绑定动态环境（先前的当前环境）到这个以符号作为名称的变量。
* 设置操作子保存的静态环境为当前环境的父环境。
* 匹配实际参数。成功匹配时，其中绑定的对象初始化环境中的变量绑定。
* 以函数体（创建时以 `<body>` 指定）中的表达式的副本作为*求值结构(evaluation structure)* ，在当前环境进行求值。

　　类似 `$vau` ，但支持额外的求值环境作为静态环境。

　　因为支持保存环境的所有权，`$vau/e` 被设计为比 `$vau` 更基本的操作。

**注释** 不考虑所有权时，`eval` 和 `$vau` 可派生 $vau/e 。

`$vau/e% <parent> <formals> <eformal> <body>`

　　同 `$vau/e` ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`wrap <combiner>`

　　包装合并子为应用子。

　　若无法为包装的合并子分配资源，则引起错误。

`unwrap <applicative>`

　　解包装应用子为[底层合并子](#合并子)。

　　左值参数解包装的结果是合并子的[子对象引用](#引用值)。

`raise-error <string>`

　　引起包含参数指定的字符串内容的错误。

**注释** 这里的错误是未归类的一般错误。

`raise-invalid-syntax-error <string>`

　　引起包含参数指定的字符串内容的语法错误。

`check-list-reference <object>`

　　检查对象是否是列表引用，若检查通过返回参数，否则引起类型检查错误。

`check-pair-reference <object>`

　　检查对象是否是有序对引用，若检查通过返回参数，否则引起类型检查错误。

`() make-encapsulation-type`

　　创建封装类型。

　　结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的*封装(encapsulate)* 构造器、判断封装类型的谓词和用于*解封装(decapsulate)* 的访问器。

　　封装构造器保留参数中的引用值。

　　解封装访问器转发参数。

　　创建的封装类型的相等性（以 `eqv?` 判断）同被封装的对象。

**原理** 关于 API 的设计，参见 [RnRK] 8.1.1 。相等性判断的规则与之不同，以允许更好地支持和宿主语言中非特定对象类型的值之间的互操作。另见 [SRFI-137](https://srfi.schemers.org/srfi-137/srfi-137.html) 引用的关于[对唯一类型的讨论](https://small.r7rs.org/wiki/UniqueTypesSnellPym/)。

## 核心库函数

　　核心库函数在基础环境中直接提供绑定。

`() get-current-environment`

　　取当前环境：取当前环境的环境弱引用。

`() lock-current-environment`

　　锁定当前环境：取当前环境的环境强引用。

`$vau <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e` ，但以当前环境代替额外的求值环境作为静态环境。

`$vau% <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e%` ，但以当前环境代替额外的求值环境作为静态环境。

`$quote <expression>`

　　求值引用操作。结果是返回值转换后的未被求值的操作数。

`id <object>`

　　结果是不隐含左值到右值转换的参数，在结果保留引用值。

　　其作用等价返回值转换，可能引起对象转移。

`idv <object>`

　　同 `id` ，但结果是返回值转换后的值。

**注释** 使用 `idv` 可指定在函数值中保留引用值的不安全操作的个别操作数不再保留引用值。

`list <object>...`

　　创建列表（类型为 `<list>` ）对象。

　　`list` 的底层合并子接受 `<pair>` 作为操作数（而不要求是列表），结果是操作数的元素经隐含左值到右值转换的值。

`list% <object>...`

　　创建列表（类型为 `<list>` ）对象，且保留参数中的引用值。

　　`list%` 的底层合并子接受 `<pair>` 作为操作数（而不要求是列表），结果是操作数。

`$lvalue-identifier? <symbol>`

　　解析当前环境中的标识符（同 `$resolve-identifier` ）并判断是否为左值（同 `bound-lvalue?` ）。

`forward! <object>`

　　转发可能是引用的值。

　　参数是右值操作数或可修改的临时对象时转移，其它情形复制。

**注释** 被转发的值若是形式参数树中的变量，一般应以带有标记字符 `&` 的形式绑定；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。

`$remote-eval <expression> <environment>`

　　在动态环境求值第二参数得到的环境中求值第一参数，结果作为函数值。

`$remote-eval% <expression> <environment>`

　　同 `$remote-eval` ，但保留引用值。

`$set! <environment> <formals> <expressions>`

　　修改指定环境的变量绑定。

　　在当前环境求值 `<environment>` 和 `<expressions>` ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 $def! 。

`$wvau <formals> <eformal> <body>`

　　创建包装的 vau 抽象。

　　同 `$vau` ，但创建的是调用时对操作数的元素求值一次的应用子。

　　参数的作用同 `$vau` 的对应参数。

`$wvau% <formals> <eformal> <body>`

　　同 `$wvau` ，但允许函数体求值返回引用值。

`$wvau/e <parent> <formals> <eformal> <body>`

　　同 `$wvau` ，但支持显式指定求值环境参数作为静态环境。

`$wvau/e% <parent> <formals> <eformal> <body>`

　　同 `$wvau/e` ，但保留引用值。

`$lambda <formals> <body>`

　　创建 λ 抽象 。

　　同 `$vau` ，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。

　　参数的作用同 `$vau` 的对应参数。

`$lambda% <formals> <body>`

　　同 `$lambda` ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`$lambda/e <parent> <formals> <body>`

　　创建指定静态环境的 lambda 抽象。

　　同 `$lambda` ，但支持显式指定的求值环境为静态环境。指定静态环境的参数含义同 `$vau/e` 。

`$lambda/e% <parent> <formals> <body>`

　　同 `$lambda/e` ，但保留引用值。

`$sequence <expression-sequence>`

　　顺序求值。操作数非空时结果是最后的参数，可能是引用值；否则结果是 `#inert` 。

　　求值每个 `<object>` 的副作用包括其中临时对象的销毁都被顺序限制。

`collapse <object>`

　　折叠可能是引用的值。

`assign%! <reference> <object>`

　　同 `assign@!` ，但 `<object>` 是引用值时赋值的源操作数是 `<object>` 折叠后的值。

`assign! <reference> <object>`

　　同 `assign%!` ，但 `<object>` 隐含左值到右值转换。

**注释** 因为左值到右值转换，即便 `<object>` 指定的值来自 `<reference>` ，也可赋值而不因此引起未定义行为。

`apply <applicative> <object> <environment>`

　　在指定环境中应用。

　　同求值 `eval% (cons% () (cons% (unwrap <applicative>) <object>)) <environment>` 。

`apply <applicative> <object>`

　　在新环境中应用。

　　同求值 `eval% (cons% () (cons (unwrap <applicative>) <object>)) (() make-environment)` 。

　　以上 apply 的函数值保留引用值。

`apply-list <applicative> <list>`

　　在新环境中应用参数列表。

`apply-list <applicative> <list> <environment>`

　　在指定环境中应用参数列表。

　　同 `apply` ，但首先检查第二参数的类型，若失败则引发错误。

`list* <object>+`

　　在列表前附加元素创建对象或有序对。

　　类似 `cons` ，但支持一个和多个操作数。

　　对一个操作数的情形结果同参数，否则结果同右结合嵌套调用参数的数量减 1 次的 `cons` 。

**注释** 一个参数的情形结果经返回值转换。

`list*% <object>+`

　　同 `list*` ，但创建有序对类似 `cons%` ，且元素保留引用值。

**注释** 一个参数的情形结果不经返回值转换。

`$defv! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau <formals> <eformal> <body>` 。

`$defv%! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau% <formals> <eformal> <body>` 。

`$defv/e! <variable> <parent> <formals> <eformal> <body>`

　　绑定指定静态环境的 vau 抽象，等价 `$def! <variable> $vau/e <parent> <formals> <eformal> <body>` 。

`$defv/e%! <variable> <parent> <formals> <eformal> <body>`

　　绑定指定静态环境的 vau 抽象，等价 `$def! <variable> $vau/e% <parent> <formals> <eformal> <body>` 。

`$defw! <variable> <formals> <eformal> <body>`

　　绑定包装的 vau 抽象，等价 `$def! <variable> $wvau <formals> <eformal> <body>` 。

`$defw%! <variable> <formals> <eformal> <body>`

　　绑定包装的 `vau` 抽象，等价 `$def! <variable> $wvau% <formals> <eformal> <body>` 。

`$defw/e! <variable> <parent> <formals> <eformal> <body>`

　　绑定包装的指定静态环境的 vau 抽象，等价 `$def! <variable> $wvau/e <parent> <formals> <eformal> <body>` 。

`$defw/e%! <variable> <parent> <formals> <eformal> <body>`

　　绑定包装的指定静态环境的 vau 抽象，等价 `$def! <variable> $wvau/e% <parent> <formals> <eformal> <body>` 。


`$defl! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda <formals> <body>` 。

`$defl%! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda% <formals> <body>` 。

`$defl/e! <variable> <parent> <formals> <body>`

　　绑定指定静态环境的 λ 抽象，等价 `$def! <variable> $lambda/e <parent> <formals> <body>` 。

`$defl/e%! <variable> <parent> <formals> <body>`

　　绑定指定静态环境的 λ 抽象，等价 `$def! <variable> $lambda/e% <parent> <formals> <body>` 。

`forward-first% <applicative> <list>`

　　取列表的第一元素并转发给指定的应用子。

　　对参数列表 `(&appv (&x .))` ，作用同求值：

```
(forward! appv) (list% ($move-resolved! x))
```

　　其中，调用 `appv` 的底层合并子的当前环境同调用 `forward-first%` 的动态环境。

`first <pair>`

　　取有序对的第一个元素的值。

　　当 `<pair>` 是左值时结果是折叠的引用值，否则结果是返回值转换后的值。

`first@ <pair>`

　　同 first ，但结果总是未折叠的引用值。

`first% <pair>`

　　同 `first` ，但结果总是转发的值。

　　转发的值是经过折叠但没有返回值转换的列表元素的值，无论参数是否为引用值。

`first& <pair>`

　　同 `first` ，但结果总是折叠的引用值。

　　首先调用 `check-list-reference` 检查参数是列表引用，对右值抛出异常。

`firstv <pair>`

　　同 `first` ，但结果总是返回值转换后的值。

`rest <pair>`

　　取有序对的第一个元素以外的元素值构成的列表。

`rest% <pair>`

　　取有序对的第一个元素以外的元素值经过转发的值构成的列表。

　　结果构成子列表，可能引入[子列表引用](#引用值)。

`rest& <pair>`

　　取有序对的第一个元素以外的元素值的引用值构成的列表的子对象引用。

　　首先调用 `check-list-reference` 检查参数是列表引用，对右值抛出异常。

　　结果构成子列表，引入子列表引用。

`set-first%! <pair> <object>`

　　修改有序对的第一个元素，保留引用值。

`equal? <object1> <object2>`

　　判断一般相等关系。

* 若参数都是[非真列表](#表达式的值和类型)，结果同两者完全分解序列中的元素对应的 `eqv?` 比较结果。
* 否则，若参数都不是有序对，结果同 `eqv?` 的比较结果。
* 否则，结果为 `#f` 。

`check-environment <object>`

　　检查环境。

　　若参数是 `<environment>` 则检查通过，结果是转发的参数；否则，引起错误。

　　检查环境通过的条件同创建合并子时的检查。

`$cond <clauses>...`

　　条件选择。

　　顺序求值 `<clause>` 中每个子项的 `<test>` ，以 `<test>` 求值结果作为条件，当条件成立时求值再求值对应的 `<body>` ，结果是求值 `<body>` 的结果。

`$when <test> <expression-sequence>`

　　条件成立时顺序求值。

　　求值 `<test>` ，结果作为条件，当条件成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

`$unless <test> <expression-sequence>`

　　条件不成立时顺序求值。

　　求值 `<test>` ，结果作为条件，当条件不成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

`$while <test> <expression-sequence>`

　　条件成立时循环求值。

　　循环求值 `<test>` ，结果作为条件，当条件成立时顺序求值 `<expression-sequence>` 。结果是最后一次 `<expression-sequence>` 求值（若存在）的求值结果。

`$until <test> <expression-sequence>`

　　条件不成立时循环求值。

　　循环求值 `<test>` ，结果作为条件，当条件不成立时顺序求值 `<expression-sequence>` 。结果是最后一次 `<expression-sequence>` 求值（若存在）的求值结果。

`not? <object>`

　　逻辑非。

　　若参数非 `#f` 时结果是 `#f` ，否则结果是 `#t` 。

`$and <test>...`

　　逻辑与。

　　顺序短路求值。操作数为空时结果是 `#t` ；参数求值存在 `#f` 时结果是 `#f` ；否则结果是最后一个参数的值。

`$or <test>...`

　　逻辑或。

　　顺序短路求值。操作数为空时结果是 `#f` ，参数求值存在不是 `#f` 的值时结果是第一个这样的值；否则结果是 `#t` 。

`and <object>...`

　　求值参数的逻辑与。

　　同 `$and?` ，但作为应用子，对每个参数都求值一次，而不短路求值，也不保证参数求值顺序。

`or <object>...`

　　求值参数的逻辑或。

　　同 `$or?` ，但作为应用子，对每个参数都求值一次，而不短路求值，也不保证参数求值顺序。

`accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3>`

　　在抽象列表的元素上应用右结合的二元操作。

　　对 `<object1>` 指定的抽象列表进行处理，取得部分和。

　　当谓词 `<predicate>` 成立时结果是参数指定的对象，否则继续处理抽象列表中余下的元素。

　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。

　　参数 `<applicative1>` 和参数参数 `<applicative2>` 应接受两个参数，否则引起错误。

　　参数 `<applicative3>` 应接受两个参数，否则引起错误。

　　调用参数中的应用子的 `<object1>` 实际参数在不同的应用子调用中可能同一。

　　调用参数中的应用子的底层合并子的当前环境同调用 `accr` 的动态环境。

`foldr1 <applicative> <object> <list>`

　　作用同符合以下要求的 `accr` 调用：

* 指定 `accr` 的参数为 `<list>` 、`null?` 、`(forward! <object>)` 、`first%` 、`rest%` 和 `<applicative>` ；
* 调用应用子 `rest%` 时不复制 `<object>` 或其子对象。

　　参数指定的应用子的调用不添加或移除列表元素，否则行为未定义。

**注释** 类似 [SRFI-1 的 `fold-right`](https://srfi.schemers.org/srfi-1/srfi-1.html#FoldUnfoldMap) ，但只接受一个真列表。

`map1 <applicative> <list>`

　　单列表映射操作，使用指定应用子对列表中每个参数进行调用，结果是调用结果的列表。

　　参数 `<applicative>` 应接受一个参数，否则引起错误。

　　操作中的应用子和列表构造的结果的确定满足过程调用的因果性；其余任意 `<applicative>` 调用的求值、列表构造操作和销毁列表中的元素的操作的相对顺序未指定。

**注释** `foldr1` 和 `map1` 名称中的 `1` 指 `<list>` 参数的个数。（更一般的其它形式可接受多个 `<list>` 。）

`list-concat <list> <object>`

　　取顺序连接的列表和对象。

`append <list>...`

　　顺序拼接列表。

`filter <predicate> <list>`

　　在列表参数中选取经谓词判断非 `#f` 的元素的值的副本创建新的列表。创建的列表的元素的顺序和列表参数中的一致。

**注释** 调用谓词的求值顺序未指定。

`derive-current-environment <environment>...`

　　创建当前环境的派生环境。

　　创建参数指定的环境和当前环境作为父环境的空环境。

`() make-standard-environment`

　　创建*标准环境(standard environment)* ：以基础环境作为唯一父环境的新环境。

`$as-environment <body>`

　　求值表达式构造环境。

　　创建以动态环境为父环境的空环境，并在其中求值参数指定的表达式。

　　结果是创建的环境强引用。

`$let <bindings> <body>`

　　局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 `<bindings>` 指定的变量绑定，再求值 `<body>` 。

`$let% <bindings> <body>`

　　同 `$let` ，但保留引用值。

`$let* <bindings> <body>`

　　顺序局部绑定求值。

　　同 `$let` ，但 `<bindings>` 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 `<bindings>` 中之前绑定的符号。

`$let*% <bindings> <body>`

　　同 `$let*` ，但保留引用值。

`$letrec <bindings> <body>`

　　顺序局部绑定求值，允许递归引用绑定。

`$bindings/p->environment (<environment>...) <binding>...`

　　转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。

`$bindings->environment <binding>...`

　　转换绑定列表为没有父环境的具有这些绑定的环境。

`symbols->imports <symbol>...`

　　转换符号列表为未求值的适合初始化符号导入列表的初值符列表。

　　结果是包含同 `desigil` 的方式移除标记字符后的参数作为间接子项的列表。

　　求值这个列表，结果是同 `forward!` 的方式转发每个符号的列表，其元素顺序和 `<symbols>...` 中的值的顺序对应。

**注释** 结果通常作为指定从某个环境中存在的绑定的 `<defindend>` 。相对直接取符号列表，这支持移除引用标记字符和转发参数。

　　结果的结构和使用满足以下约定：

* 结果中可能存在合并子作为其子对象，其参数可能求值多次；
* 取结果中的子对象进行求值的行为未定义；
* 若结果被修改（如被转移），再求值时行为未定义；
* 若结果中的合并子在求值整个结果外的上下文被调用，行为未定义。

**注释** 以上约定可允许更有效的本机实现，不保证在实现中检查。

`$provide/let! <symbols> <bindings> <body>`

　　在当前环境中提供绑定：蕴含 `$let <bindings> <body>` ，在求值 `<body>` 后以结果作为操作数绑定到 `<symbols>` 的符号。

　　`<symbols>` 应能被作为 `<defindend>` 使用。

　　结果是对这些绑定具有所有权的环境强引用。

**注释** 绑定后的符号可通过作为 vau 抽象的父环境等形式依赖这个环境，因此用户需适当保存求值 vau 抽象得到的合并子对象使其生存期覆盖在被使用的绑定符号指称的对象生存期。

　　需要导入符号（即 `<symbols>...` 具有至少一个实际参数）时，以同 `symbols->imports` 的方式确定初值符。其中，等效的 `symbols->imports` 的求值次数未指定。

`$provide! <symbols> <body>`

　　求值第二参数并在当前环境绑定结果到第一参数指定的符号。

　　结果是带有这些绑定的环境。

　　需要导入符号时，以同 `symbols->imports` 的方式确定初值符。其中，等效的 `symbols->imports` 的求值次数未指定。

`$import! <environment> <symbols>`

　　从第一参数指定的环境导入第二参数指定的符号。

　　需要导入符号时，以同求值 symbols->imports 应用子的结果的方式确定初值符。其中，等效的 symbols->imports 的求值次数未指定。

## 续延

　　*续延(continuation)* 是关于某个表达式求值的当前上下文中待求值的资源。

**注释** 续延可看成特定上下文移除某个表达式得到的剩余待求值项。例如，对函数 `+` 及参数值 `1` 和 `2` ，函数应用表达式 `+ 1 2` 在关于参数 `1` 作为待求值的表达式的续延逻辑上可表达为 `+ [] 2`，其中 `[]` 表示上下文中待确定后继续在余下的计算步骤中使用的值的占位符。

　　类似合并子，续延可被*调用(call)* ，并接受一个参数。续延的参数是上下文接受的待求值的对象。被调用的续延执行其蕴含的其余求值步骤。

**注释** 参数在调用中替换 `[]` 位置的值，这类似函数调用的实际参数替换形式参数。续延不是合并子，和应用子不同，它在调用前不对参数进一步求值。

　　求值算法隐含的续延调用对应的程序执行是*正常(normal)* 的。其余情形的续延调用对应*非正常(abnormal)* 的程序执行，隐含控制作用。

　　一等续延是续延被*捕获(capture)* 而在程序中*具现(reify)* 的一等对象。

　　类似函数，续延对象可通过构造特定的表达式被*应用(apply)* ，以被显式地调用。

　　因为剩余的计算依赖续延的参数，通过非正常的控制改变正常续延调用的参数，可改变程序执行的流程。

**注释** 上例中，续延 `+ [] 2` 在 `[]` 处接受一个参数。正常调用时，参数是 `1` 。若通过某种方式捕获续延，并以程序指定和 `1` 不同的值作为参数被续延调用，可改变之后的程序执行流程。

　　续延可支持以下求值得到的操作数：

* `<continuation>` ：一等续延。

`call/1cc <combiner>` 

　　捕获*一次(one-shot)* 续延，具现为一等续延作为参数调用合并子。

　　续延首先在尾上下文中被捕获为引用值，再作为操作数，调用 `<combiner>` 。

　　来自同一具现的一次续延的任何副本只允许一次显式（续延应用）或者隐式（如被函数调用的返回蕴含）地成功调用；否则，调用被[重入](#函数) ，引起[错误](#诊断) 。

　　捕获的续延之后允许被复制。

`continuation->applicative <continuation>`

　　转换续延为应用子。

　　结果是转换的 `<applicative>` 类型的值。

　　在构造结果时，`<continuation>` 被转发。

　　结果的底层合并子被调用时，传递操作数树给 `<continuation>` 。

## 代理求值

　　代理求值操作加载为基础环境下的 `std.promises` 环境。

　　代理求值可支持以下求值得到的操作数：

* `<promise>` 求值代理：表示可被求值取得结果的对象。
	* 保存待求值的表达式和环境，或已求值的结果。

**注释** 在 `<promise>` 上的并发访问并不具有特别的同步保证和要求。

`promise? <object>`

　　判断参数是否为 `<promise>` 类型的值。

`memoize <object>`

　　记忆化求值：以参数作为已被求值的结果创建 `<promise>` 对象。

　　在结果中保留参数的引用值。

`$lazy <body>`

　　延迟求值：以参数为待求值的表达式，以当前环境作为这个表达式被求值的动态环境，创建 `<promise>` 对象。

`$lazy% <body>`

　　同 `$lazy` ，但保留引用值。

`$lazy/d <environment> <body>`

　　同 `$lazy` ，但以参数指定环境替代动态环境。

`$lazy/d% <environment> <body>`

　　同 `$lazy%` ，但以参数指定环境替代动态环境。

`force <promise>`

　　立即求值指定的 `<promise>` 对象。

　　若参数在求值时修改为非 `<promise>` 类型的对象，需要继续迭代求值时，引起类型错误。

**注释** 通过 `force` 引起 `<promise>` 对象的求值可能蕴含修改这个对象而使其中的状态失效的操作（如通过 `assign!` ）。因此，实现中需要重新访问状态，而重新进行类型检查。

**原理** 代理求值的原语可实现[惰性求值](https://en.wikipedia.org/wiki/Lazy_evaluation)和透明的[记忆化](https://en.wikipedia.org/wiki/Memoization)求值。和一些流行的误解不同，尽管这些原语的[原始设计](https://en.wikipedia.org/wiki/Futures_and_promises)是关于并行处理的，这不必然蕴含并发的[投机执行](https://en.wikipedia.org/wiki/Speculative_execution)，只是因为*解析(resolve)* 内部状态并不在用户程序中可见，而蕴含必要的最小同步。由于当前语言不支持并发访问，即使是对 `<promise>` 的修改操作导致改变对象蕴含的状态，在语言中其状态也不可见，没有要求支持这种同步；未来可能会附加要求以提供更完善的并发支持。关于 API 的设计，参见 [RnRK] 第 9 章和 [SRFI-45](https://srfi.schemers.org/srfi-45/) 。
	
## 字符串操作

　　字符串操作加载为基础环境下的 `std.string` 环境。

　　字符串操作支持以下求值得到的操作数：

* `<regex>` 正则表达式类型。

`string? <object>`

　　`<string>` 的[类型谓词](#操作类型约定)。

`++ <string>...`

　　字符串串接。

`string-empty? <string>`

　　判断字符串是否为空。
　　
`string<- <string1> <string2>`

　　字符串赋值。

　　以第二参数为源，修改第一参数指定的目标。

`string=? <string1> <string2>`

　　判断字符串是否相等。

`string-split <string1> <string2>`

　　取第二参数分隔第一参数得到的字符串的列表。

`string-contains? <string1> <string2>`

　　判断第一参数是否包含第二参数作为子串。

`string-contains-ci? <string1> <string2>`

　　判断第一参数是否包含第二参数作为子串，忽略大小写。

　　只在单字节字符集内的字符中区分大小写。

`string->symbol <string>`

　　转换字符串为符号。

`symbol->string <symbol>`

　　转换符号为字符串。

`string->regex <string>`

　　创建字符串初始化的正则表达式。

`regex-match? <string> <regex>`

　　在字符串中搜索正则表达式指定的模式串。

`regex-replace <string1> <regex> <string2>` 

　　替换字符串中的模式串，构造新字符串。

　　在 `<string1>` 的副本中搜索正则表达式指定的模式串的所有匹配，替换为 `<string2>` 指定的格式字符串。

　　结果是替换后的字符串。

## 数学库

　　数学库加载为基础环境下的 `std.math` 环境。

　　Unilang 数值是 Unilang 对数学意义上的*数(number)* 的建模。

　　被建模的数是 Unilang 数值的*真值(true value)* 。

　　Unilang 数值的集合到真值的集合的映射是满射；除此之外，也存在不被 Unilang 数值建模的数，这些数可能被未来的版本支持作为真值。

　　除非另行指定，Unilang 数值的行为由对应的真值的数学含义决定。

　　数学库主要支持关于数值类型的操作。

　　数值操作可支持以下求值得到的操作数：

* `<number>` ：数值。
* `<real>` ：实数。
* `<rational>` ：有理数。
* `<integer>` ：整数。
* `<int>` 内部实现使用的整数类型。
	* **注释** `<int>` 对应 C++ 的 `int` 类型。主要用于互操作。

　　以上类型不都互斥，即一个数值可以同时具有以上的不同的类型。数值之间的子类型关系由数学定义蕴含，即以上类型中，后者依次是前者的子类型。

	当前所有 `<number>` 都是 `<real>` 。

**注释** 按具体操作的逻辑，仍然区分 `<number>` 和 `<real>` 的操作数。未来可能添加新的数值类型，或改变内部实现使用的不同数值类型的支持。

　　和数学意义上的数值不同，`<real>` 也包含以下可带符号的特殊值：

* 无限大值。
* NaN(not a number) 值。

**注释** 无限大值在数学意义上是超实数(hyperreal number) ，也作为扩展实数(extended real number) 的值；NaN 不是数学意义上的数，表示特定的没有数学定义的计算结果。

　　根据是否具有数学上可严格定义相等性的确切表示（精确性(exactness) ），数值分为*精确数(exact number)* 和*不精确数(inexact number)* 。

　　精确数和对应的真值总是相等；不精确数和真值不严格相等。

　　有限的不精确数的偏离程度可通过实数描述，即（绝对）*误差(error)* 。精确数的误差恒等于 0 。数值的绝对*精度(precision)* 是其内部表示蕴含的误差的上界的倒数。对确定使用进位制的表示，精度也指精确表示的数值位数，即数量级精度。数值的内部表示中能以实数描述的度量应至少具有整数数量级精度，即误差不大于 1 。

**注释** 整数精度外的数量级精度仅在确定使用进位制的底数时和绝对精度可比较。但是，不比较具体大小时，有限的数量级精度和绝对精度性质可以一致，这种上下文可不区分两者。

　　精确数和不精确数在数值上可能相等，而类型不同。

**注释** 这影响一般的等价谓词的结果，如 `eqv?` 。比较数值相等，一般应使用本节的操作 `=?`。

　　不精确数的零值有不同的符号，不是相同的数值，但在数值上相等。

　　数值字面量是数值的外部表示。以外部表示求值的数值具有如下性质：

* 起始的 `+` 和 `-` 指定符号。若符合规则的数值字面量没有指定符号，则隐含为 `+` 。
	* **注释** 不精确数可能在内部表示支持不同符号的零值。
* 除非绝对值大于可表示的范围，十进制整数数值具有 `<integer>` 类型，是精确数；否则，十进制整数具有 `<real>` 类型，是不精确数。
* 十进制小数数值和特殊值具有 `<real>` 类型，是不精确数。
	* 若字面量指定的数值小于或大于使用的类型的数值表示范围，则值为对应类型具有相同符号的零值或无限大值。
	* 不精确数数值字面量的解析使用未指定的浮点数舍入模式，其误差不大于最后一个在规格化范围内表示的十进制小数位为 1 时的绝对值的真值大小（以任意可能符合宿主语言要求的舍入模式下的最大值计）。
	* 科学记数法外部表示中，有效数字和指数构成的真值和内部表示可具有误差。
* 数值具有的其它子类型和内部表示未指定。

　　数值的外部表示和内部表示应支持往返(round-trip) 转换，即转换的内部或者外部表示输出可被输入接受。

　　往返转换中，精确数转换保持任意（无限）精度；不精确数经有限次转换不继续损失精度。

**注释** 即便损失精度，也应总是满足结果至少不低于整数精度。

　　除非另行指定：

* 在数学上有意义的前提下，数值操作同时支持以上尽可能多的数值类型的操作数。
* 数值操作对预期的数值操作数进行类型检查，失败时出错。
* 数值操作不区分数值操作数中对应的真值相等的精确数或不精确数。
* 可假定数值操作数和计算过程中不出现 SNaN(signaling NaN) 值；
* 若作为操作数的精确数决定计算结果在数学上未定义，则引起错误。
* 不精确数计算中的舍入方式未指定。
* 若计算结果是数值，则：
	* 若被计算结果依赖的任一操作数中具有 NaN 值，则依赖这个操作数的数值操作结果也是 NaN 值。
	* 输出的类型的值域能表示操作结果；除操作的语义和本节的其它规则蕴含外，具体类型未指定。
	* 若作为操作数的精确数决定的计算结果是不精确数表示的有限数值，则这个不精确数应是所有相同内部表示的数值中和结果的真值误差最小的数值。
	* 对数学上封闭的计算，结果具有不超过所有数值操作数范围的数值类型。
	* 除非不能在结果类型中表示计算结果的范围：
		* 若数值操作的所有数值操作数都是精确数，结果不是不精确数。
		* 数值操作的实现不损失按数学定义得到的中间结果的精度；结果的误差仅来自其依赖的数值操作数引入的累积误差。
	* 若计算结果是不精确数，则：
		* 若计算结果是小于最小可唯一表示的 `<real>` 值，则对应的数值操作结果是不精确数 0 。
		* 计算结果中真值等于 0 的数值以及 NaN 值的符号是未指定的。
		* 若计算结果中无限大数值不能通过数学上有意义的方式确定符号，则对应的数值操作结果是无限大值或 NaN 之一，具体选择未指定。

　　所有除法和取余数的计算符合除法约定：

* 二元除法或者取余数的操作中，第一个参数是被除数，第二个参数是除数。
* 当除数是不精确数 0 时：
	* 若被除数是非零有限数值或无限大值，则商的符号同被除数的符号。
	* 否则，商的符号未指定。
* 当被除数是不精确数时，若除数是精确数 0 ，则结果除符号外同除数是不精确数 0 的情形。
* 同时计算商和余数的操作的结果是商和余数构成的列表。

`number? <object>`

　　`<number>` 的[类型谓词](#操作类型约定)。

`real? <object>`

　　`<real>` 的类型谓词。

**注释** 同 `number?` ，因为当前 `<number>` 都是 `<real>` 值。

`rational? <object>`

　　`<rational>` 的类型谓词。

**注释** 当前实现仅需排除无限大和 NaN 值。

`integer? <object>`

　　`<integer>` 的类型谓词。

`exact-integer? <object>`

　　判断参数是否为 `<integer>` 类型的精确数对象。

`exact? <number>`

　　断参数是否为精确数。

`inexact? <number>`

　　判断参数是否为不精确数。

`finite? <number>`

　　判断参数是否为有限值。

`infinite? <number>`

　　判断参数是否为无限大值。

`nan? <number>`

　　判断参数是否为 NaN 值。

`zero? <number>`

　　判断参数是否为零值。

`=? <number1> <number2>`

　　比较相等。

`<? <number> <number>`

`<=? <number> <number>`

`>=? <number> <number>`

`>? <number> <number>`

　　数值关系操作，分别为：小于、小于等于、大于等于和大于。

　　结果是 `<boolean>` 类型的比较结果。

`zero? <number>`

　　判断参数是否为零值。

`positive? <real>`

　　判断参数是否为正数。

`negative? <real>`

　　判断参数是否为负数。

`odd? <real>`

　　判断参数是否为奇数。

`even? <real>`

　　判断参数是否为偶数。

`max <real1> <real2>`

　　计算参数中的最大值。

`min <real1> <real2>`

　　计算参数中的最小值。

`add1 <number>`

　　计算参数加 1 的值。

`sub1 <number>`

　　计算参数减 1 的值。

`+ <number> <number>`

　　加法：计算参数的和。

`- <number> <number>`

　　减法：计算参数的差。

`* <number> <number>`

　　乘法：计算参数的积。

`/ <number> <number>`

　　除法：计算参数的商。

`abs <real>`

　　计算参数的绝对值。

`floor/ <integer1> <integer2>`

　　数论除法：计算参数向下取整的整除的商和余数。

`floor-quotient <integer1> <integer2>`

　　数论除法：计算参数向下取整的整除的商。

`floor-remainder <integer1> <integer2>`

　　数论除法：计算参数向下取整的整除的余数。

`truncate/ <integer1> <integer2>`

　　数论除法：计算参数截断取整的整除的商和余数。

`truncate-quotient <integer1> <integer2>`

　　数论除法：计算参数截断取整的整除的商。

`truncate-remainder <integer1> <integer2>`

　　数论除法：计算参数截断取整的整除的余数。

`div <int> <int>`

　　整除：结果是 `<int>` 类型的商。

`mod <int> <int>`

　　模：结果是 `<int>` 类型的余数。

`itos <int>`

　　转换整数为字符串表示。

`stoi <string>`

　　转换整数的字符串表示为整数。若失败，则引起错误。

## I/O 库

　　I/O 库的操作加载为基础环境下的 `std.io` 环境。

`() newline`

　　输出换行并刷新缓冲。

`readable-file? <string>`

　　判断参数指定的文件名对应的文件是否存在且可读。

`load <string>`

　　加载参数指定的翻译单元。

　　当前实现中的参数为文件系统路径。

　　被加载的翻译单元视为对象的外部表示 ，经读取翻译为 Unilang 对象。

　　求值被加载后读取的对象，并以其求值结果作为表达式的求值结果。

`() read-line`

　　从标准输入读取一行输入作为字符串。

　　结果类型是 <string> 。

`write <object>`

　　写对象的外部表示。

　　输出的目标为标准输出。

　　输出的外部表示符合以下格式约定：

* 除非派生实现另行指定且值的格式没有在此指定，左值的外部表示同其经左值到右值转换取得的值。
* 数值和字符串的输出其源代码中可以求值到相等的值的表示。
	* **注释** 字符串以 `"` 作为输出的起始和结束。
* 列表以 `(` 和 `)` 作为输出的起始和结束。
* 空列表不输出元素；非空列表的元素顺序输出，之间以空白符分隔。

　　其余具体格式未指定。

`display <object>`

　　输出对象的外部表示。

　　同 `write` ，但输出字符串没有字面量的引号。

`put <string>`

　　输出字符串。

`puts <string>`

　　输出字符串和换行并刷新缓冲。

## 系统库

　　系统库的操作加载为基础环境下的 `std.system` 环境。

`env-get <string>`

　　取宿主环境的环境变量字符串。

　　字符串参数指定环境变量的名称。

## 模块管理

　　模块管理操作加载为基础环境下的 `std.modules` 环境。

模块约定：

　　*需求字符串(requirement string)* 是具有 `<string>` 类型的非空字符串。

　　若操作的形式参数是需求字符串，实际参数是空字符串，则引起错误。

　　本模块共享可变状态以支持操作访问确定的模块字符串集合。

　　本模块隐含一个字符串序列作为需求字符串模板。

　　除非派生实现另行指定，需求字符串模板初始化后不可变。

　　需求字符串模板初始化的值由实现定义。

`registered-requirement? <string>`

　　判断参数是否是已在本模块注册的需求字符串。

`register-requirement! <string>`

　　在本模块注册参数为需求字符串。

`unregister-requirement! <string>`

　　在本模块注册解除参数为需求字符串。

`find-requirement-filename <string>`

　　查找需求字符串对应的文件名。

　　在需求字符串模板中顺序地搜索字符串，返回匹配字符串的结果。若不存在这样的结果，则引起错误。

　　判断需求字符串模板中的每一个字符串是否能被需求字符串匹配时，首先替换字符串中的单字符子串 "?" 为需求字符串，取得替换结果，再判断它是否为可读的文件的文件名。

　　替换字符串时，每一个子串被同时一次替换；不对替换结果进一步递归地替换。

`require <string>`

　　按需加载需求字符串对应的模块。

　　若参数指定的需求字符串没有注册，则注册需求字符串并加载同调用 `find-requirement-filename` 等价的方式搜索得到的结果；否则没有作用。

## 类操作

　　类操作提供被称为*类(classe)* 的一类封装类型。

**注释** 类类型在其它一些语言被原生支持。

　　类操作加载为基础环境下的 `std.classes` 环境。

　　类操作可支持以下求值得到的操作数：

* `<class>` 类：通过类操作创建的标识类类型的对象。
	* 一个类可能具有可选的一个*基类(base class)* 。
	* 一个类可以关联应用子作为其*构造器(constructor)* 。
		* **注释** 构造器的实现可同时支持不同的参数。不支持*重载(overload)* 多个构造器。
	* 类可具有若干个*成员(member)* 。
		* 每个类中，不同的成员具有不同的名称。
		* 成员通过类和名称访问。
		* **注释** 访问类的成员和环境中的变量绑定类似。
* `<class-object>` 类的对象：通过 `<class>` 的实例创建的对象。
	* 特定类的对象或值是这个类的*实例(instance)* 。
	* 初始化类的实例时，其引用被被作为构造器的第一个参数。
* `<class>` 和 `<class-object>` 都是封装类型。
* 两个 `<class>` 或 `<class-object>` 对象，当且仅当其内容满足 `equal?` 时，`eqv?` 结果为 `#t` 。

`class? <object>`

　　`<class>` 的[类型谓词](#操作类型约定)。

`make-class <object> <applicative>`

　　以参数为基类和构造器创建类。

　　参数应为 `()` 或者 `<class>` 的值。若为前者，则视为不存在基类。

`object? <object>`

　　`<class-object>` 的类型谓词。

**注释** 这不是 `<object>` 的类型谓词。

`make-object <class> <object>...`

　　创建以第一个参数指定的类的对象。

　　创建对象时，以被构造的类实例中的成员共享的环境引用和之后的可选参数作为构造器的操作调用其构造器。

`$access <class-object> <expression>`

　　访问第一个参数指定的类的对象中以第二个参数指定的表达式求值确定的成员。

**注释** 典型地，第二个参数一般是同成员名称的未求值的符号。

## 辅助功能

　　包含当前设计中未归类的以标准库提供的辅助运行时功能。

`random.choice <list>`

　　若参数非空，随机选择其元素作为结果；否则引起错误。

## 系统互操作

　　系统互操作包含和外部实现环境交互的操作。

　　使用的类型参见[算术操作](#算术操作)。

`sys.exit <int>`

　　以指定返回值退出进程。相当于调用 C++ 标准库的 `std::exit` 。

## 外部语言交互接口

　　外部语言交互接口是支持系统交互的底层 API ，主要以外部函数接口(FFI, foreign function interface) 的形式体现，支持调用 C 语言和兼容二进制实现的动态库中的函数。

　　外部语言交互支持以下求值得到的操作数：

* `<ffi-library>` FFI 库对象，表示一个适用外部语言交互的动态库的对象。
* `<ffi-call-interface>` FFI 调用接口对象，描述使用 FFI 调用函数需要的参数和返回类型信息。

　　系统互操作在基础环境中直接提供绑定。

`ffi-library? <object>`

　　判断参数是否为 `<ffi-library>` 对象的[类型谓词](#操作类型约定)。

`ffi-load-library <string>`

　　从参数指定的外部位置加载动态库。求值的结果是表示加载的动态库的 `<ffi-library>` 对象。

`ffi-call-interface? <object>`

　　判断参数是否为 `<ffi-call-interface>` 对象的类型谓词。

`ffi-make-call-interface <string1> <string2> <list>`

　　创建 FFI 调用接口。

　　参数分别为表示 ABI 的字符串、表示返回类型的字符串和一个表示函数参数类型的字符串的列表。

　　当前支持的 ABI 应为 `"FFI_DEFAULT_ABI"` 。

　　支持的类型表示如下：

* `"string"` 以指针编码的 C 字符串。对应语言内的 `string` 类型。
* `"void"` 仅用于返回类型 `void` 。
* `"sint"` 类型 `int` 。
* `"sint"` 类型 `int` 。
* `"pointer"` 以 `void*` 编码的对象指针类型。
* `"uint8"` 类型 `uint8_t` 。
* `"sint8"` 类型 `int8_t` 。
* `"uint16"` 类型 `uint16_t` 。
* `"sint16"` 类型 `int16_t` 。
* `"uint32"` 类型 `uint32_t` 。
* `"sint32"` 类型 `int32_t` 。
* `"float"` 类型 `float` 。
* `"double"` 类型 `double` 。

`ffi-make-applicative <ffi-library> <string> <ffi-call-interface>`

　　创建以 FFI 调用 C 函数的应用子。

　　参数指定 FFI 库、函数名称和 FFI 调用接口。

　　不支持 C 函数的可变参数。

`ffi-make-callback <applicative> <ffi-call-interface>`

　　创建 FFI 回调函数对象。

# 上层语言特性

　　基于基础语言，上层语言提供一些替代和补充的特性，可使具有其它语言背景的用户更易使用。

## 核心语言扩展特性

　　核心语言扩展特性提供不在核心语言中指定的附加语法。

### 扩展语法

　　补充基本语法的文法元素：

```
<extended-left-list-bound> ::= [ | {
<extended-right-list-bound> ::= ] | }
```

　　每个元素都被视为分隔符，且应满足如下匹配：

* `(` 和 `)` 。
* `[` 和 `]` 。
* `{` 和 `}` 。

　　不满足匹配引起语法错误。

### 扩展中缀变换

**注意** 本节描述的是试验特性，可能在之后的语言版本中改变。

　　扩展中缀变换和基础语言的中缀变换类似，变换特定的记号为前缀操作符但优先级低于中缀变换的中缀记号，且记号不被视为分隔符。

**注释** 这意味着被中缀扩展的记号为和其它记号区分，之间需要有空白符分隔。

　　扩展中缀变换的 `<infix>` 定义的操作符支持两类中缀操作：

* 二元左结合操作：在构成表达式的记号序列中自左向右查找中缀操作符，变换后的第二操作数作为子表达式，继续替换其中的记号序列，直至已被变换的记号序列的右侧没有更多的操作数和操作符记号。
	* **示例** 对中缀操作符 `+` ，变换 `X + Y + Z` 为等效 `(+ (+ X Y) Z)` 的表达式。
* 二元右结合操作：在构成表达式的记号序列中自右向左查找中缀操作符，变换后的第二操作数作为子表达式，继续替换其中的记号序列，直至已被变换的记号序列的左侧没有更多的操作数和操作符记号。
	* **示例** 对中缀操作符 `+` ，变换 `X + Y + Z` 为等效 `(+ X (+ Y Z))` 的表达式。

　　和基础语言的中缀变换不同，以下上下文中不进行二元操作的扩展中缀变换：

* 左结合操作的最后一个操作符是记号序列中的最后一个记号。
* 右结合操作的第一个操作符是记号序列中的第一个记号。
* 任一待变换的记号序列中，第一个记号是 `()` 的记号序列。
	* **注释** 这允许特定表达式及其子表达式不使用二元操作的中缀变换规则。使用 `()` 停用中缀变换的作用是递归的。为简化规则，当前不提供恢复在子表达式的记号序列中重新启用中缀变换的语法。

**注释** 具体中缀操作待定义。

　　当前支持的具体中缀操作都是二元操作，优先级自高到低如下：

* `*` 和 `/` ：左结合，替换为作为前缀操作的对应符号。
* `+` 和 `-` ：左结合，替换为作为前缀操作的对应符号。
* `<`、`>`、`<=` 和 `>=` ：左结合，替换为作为前缀操作的对应符号。
* `=` 和 `!=` ：左结合，替换为作为前缀操作的对应符号。
* `:=` ：右结合，替换为作为前缀操作的符号 `assign!` 。
	* **注释** 使用 `=` 而不是 `:=` 表示赋值，这和 C 、C++ 和 Java 等语言不同，而和 ALGOL 、Effiel 和 Ada 等语言的设计类似。另外的非对称选项如 APL 使用的 `←`（转写为 R 的 `<-`）。
	* **原理** 和 C 、C++ 和 Java 等语言不同，操作符 `=` 遵循更传统的含义表示等于，其对称性蕴含作为等价关系交换左右操作数不改变程序的语义，避免和赋值混淆。
		* 使用 `:=` 表示赋值，和 ALGOL 、Effiel 和 Ada 等语言的设计类似。
		* 另外的非对称选项如 APL 使用的 `←`（转写为 R 的 `<-`）。
		* BASIC 以 `LET ... = ` 语法表示赋值，允许省略 `LET` 后也会造成类似的混淆。
		* 注意使用 `==` 表示赋值的设计的其它论断在当前程序设计的实践中普遍缺乏实证，而不被采用。
			* [K.Thompson 曾评价 C 使用 `==` 的设计理由](https://ia801303.us.archive.org/1/items/TheCProgrammingLanguageFirstEdition/The%20C%20Programming%20Language%20First%20Edition%20%5BUA-07%5D.pdf)：Since assignment is about twice as frequent as equality testing in typical programs, it’s appropriate that the operator be half as long. 这在大多数不使用 C 的语言中并不适用，因为配合其它特性，实践中赋值更多地作为局部实现细节，而不需要大部分在高级语言操作中出现。
			* 特别地，还存在许多完全不支持赋值的纯函数式风格为了消除副作用，鼓励尽量或者完全不使用赋值。
			* `==` 可能在其它语言中也表示其它的含义。例如，形式验证语言 [TLA+](http://lamport.azurewebsites.net/tla/tla.html) 中，[`==` 是符号 ≜ 的 ASCII 转写](https://github.com/tlaplus-community/tlaplus-standard/blob/main/unicode/tla-unicode.csv)，表示操作定义相等。
		* 因此，即便不考虑混淆风险，赋值占用 `=` 经常是一种语法上的浪费。
			* 即便是类似 C 的不限制使用副作用的语言，也存在赋值以外的一些可能更基本的具有副作用的操作。例如，C++ 的对象交换操作在考虑异常安全性时比赋值是更基本的操作，并[因此曾被提议为单独的操作符](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3746.pdf)。
			* 即便是兼容 C 的语言，如 C++ ，初始化被独立于赋值强调。没有遵循 C 之前参照的更早的 CPL 等语言对初始化和赋值的不同语法的设计，对 C++ 只是兼容 C 的历史偶然。
		* [Go 使用 `:=` 表示带初始化的声明](https://go.dev/ref/spec)。尽管没有 C（以及 C++ 的部分）初始化和赋值语法的混淆，仍然支持 `=` 表示赋值不能消除对称性预期的破坏。因此这里不采用这种设计。
		* 关于赋值操作符在相关语言中的演化的历史，另见[这里](https://www.hillelwayne.com/equals-as-assignment/)。

## 库特性

　　基于基础语言，上层语言提供更多的库。

　　一些定义提供标准库的实体别名。作为简化写法，可能不遵循标准库中函数的命名约定。

　　除非另行指定，这些定义同一个环境中绑定。

### 显式类型扩展

　　与核心语言不同，部分库特性允许显式指定*类型标记(type annotation)* 以明确特定上下文中变量或其它实体可对应确定的类型。

　　类型可通过其它的组合构造。为构造类型新的类型，核心语言支持的类型被视为不可分的*基本类型(primitive type)* 。其它类型是*组合类型(composite type)* 。

**注释** 关于核心语言支持的类型，参见附录。

　　除操作对应用子参数的求值和操作数的类型检查外，当前任何操作中添加的标注类型不要求具有作用。

**注释** 当前不要求支持需要访问已知标注类型的功能。

### 基础语言实体别名

　　以下名称在启用上层语言的初始环境可用，而不需要程序显式地在当前环境中引入或定义。

　　在本节指定为别名的定义和对应的标准库函数具有同一性，即 `eq?` 比较相等。

* 字符串操作：
	* `++`
* 数学库操作：
	* `+`
	* `-`
	* `*`
	* `/`
* I/O 库：
	* `newline`
	* `load`
	* `display`
	* `puts`
* 定义实体别名：
	* `=` ：同数学库函数 `=?` 。
	* `<` ：同数学库函数 `<?` 。
	* `>` ：同数学库函数 `>?` 。
	* `<=` ：同数学库函数 `<=?` 。
	* `>=` ：同数学库函数 `>=?` 。
	* `def` ：同核心库函数 `$def!` 。
	* `import` ：同核心库函数 `$import!` 。
	* `not` ：同核心库函数 `not?` 。
	* `unless` ：同核心库函数 `$unless` 。
	* `until` ：同核心库函数 `$until` 。
	* `when` ：同核心库函数 `$when` 。

**注释** 不显式指定为别名的函数也可能实现为别名。

### 控制操作

`if <test> <consequent> else <alternate>`
`if <test> <consequent>`

　　条件分支，功能同核心库的 `$if` ，但表达式不能是符号 `else` ，否则引起错误。

`while <test> <expression-sequence>`

　　循环求值，功能同核心库的 `$while` 。

### 数学库

`!= <number1> <number2>`

　　比较不等。

### 字符串扩展库

`putss <string>...`

　　串接参数并输出。输出方式同标准库模块 `std.io` 的 `puts` 。

`stoi-exact <string>`

　　精确转换整数的字符串表示为整数。若失败，则引起错误。

　　使用标准库模块 `std.math` 的操作；同 `stoi` ，但若结果应用 `itos` 得到的结果和参数不相等，则引起错误。

`rmatch? <string1> <string2>`

　　匹配视为正则表达式的字符串。

　　使用标准库模块 `std.strings` 的操作；设参数列表 `(&x &r)` ，结果同求值 `regex-match? x (string->regex r)` 。

### 类型库

　　类型库支持显式类型扩展。

　　类型库支持以下求值得到的操作数：

* `<type>` ：类型：表达某个类型的值的集合。
	* `<type>` 类型的值的相等性表达类型的相等性。
	* 当前要求仅提供在语言规则或库中明确支持的基本类型，不实现组合类型。

　　类型库支持以下类型为 `<type>` 的对象：

* `Any` ：任意类型，即 `<object>` 类型。
* `List` ：`<list>` 类型。
* `String` ：`<string>` 类型。
* `Number` ：`<number>` 类型。

**注释** 按核心语言的类型规则要求，这些对象应互不相等。

　　类型库支持以下符合标准库命名风格的操作：

`type? <object>`

　　`<type>` 的[类型谓词](#操作类型约定)。

`type->string <type>`

　　转换参数为描述其实现的字符串。

　　对不相等的参数应具有不同的结果。

`has-type? <object> <type>`

　　判断第一参数是否具有第二参数指定的类型。

**注释** 注意参数隐含左值到右值转换。

`: <variable> <type>`

　　为变量指定类型标注：*声明(declare)* 第一参数指定的变量具有第二参数的类型。

`typed-ptree->ptree <object>`

　　转换参数指定的可能包含类型标注的形式参数树为一个不包含类型标注的形式参数树。

　　类型标注的形式参数树可能是经中缀转换标点 `,` 的结果，即以一个等效标准库的 `list%` 的右值作为第一个子表达式。这种情形下，第一个子表达式被忽略。

**注释** 在简化的实现中，可直接判断等于。这不确保可移植，因为语言不保证变换结果的第一个子表达式是否等于 `list%` ；这是语言实现细节。

　　若参数不符类型标注的语法要求，则引起错误。

**注释** 不要求检查类型标注以外的部分符合形式参数树的要求。

### 类型标注操作

　　基于标准库和类型库，以下操作除在 `<defindend>` 、`<formals>` 和 `<bindings>` 中绑定的变量名的位置支持类型标注外，和标准库函数功能相同：

* `def` ：同核心库函数 `$def!` 。
* `lambda` ：同核心库函数 `$lambda` 。
* `defn` ：同核心库函数 `$defl!` 。
* `let` ：同核心库函数 `$let` 。
* `let*` ：同核心库函数 `$let*` 。
* `letrec` ：同核心库函数 `$letrec` 。

### 异常库

　　异常库提供异常处理操作。

`try/catch` <expression1> <expression2>

　　求值第二个表达式，保存其结果作为*异常处理器(exception handler)* ；然后求值第一个表达式。

　　若第一个表达式的求值中有 `throw` 的调用（参见以下描述），则中止求值，转移控制，以 `throw` 调用的操作数的求值得到的*异常对象(exception object)* 作为唯一的操作数，调用异常处理器。

　　异常处理器调用同函数应用。

**注释** 若异常调用器不是一个能接受异常对象为参数的合并子，则引起错误

`throw` <expression>

　　求值表达式，并跳转到包含 `throw` 调用的最内一层的 `try/catch` 表达式。

　　若这个 `throw` 调用不在 `try/catch` 的第一个操作数中出现，则引起错误。

### 测试库

　　测试库引入测试接口，具有以下符合标准库命名风格的对象和操作：

`info <string>...`

　　输出测试用例标题，包含串接的参数。

`subinfo <string>...`

　　输出子测试用例标题，包含串接的参数。

`moved? <object>`

　　判断对象具有转移后的状态。不排除假阳性结果。

**原理** 语言显式指定转移后的状态具有未指定值。具体的值和实现相关。

`unit`

　　具有一个和其它类型的值不同的[单元类型](https://en.wikipedia.org/wiki/Unit_type)的值的对象。

**注释** 用于需要左值的测试用例。

`Unilang_TestOpts_QuickFail`

　　值指定是否错误停止测试的对象。

	初始值为 `#t` 。

`report-failure <string>`

　　报告测试错误。

　　当 `Unilang_TestOpts_QuickFail` 为 `#t` 时同核心库的 `raise-error` ，否则同 标准库`puts` 。

　　以下函数中，报告测试失败时使用这个函数。

函数 `pass <object>...` ：输出表示测试检查通过的消息。

　　当前忽略参数。

　　以下函数中，测试通过时以测试结果调用这个函数。

`fail-on-check <object> <object>`

　　报告测试检查失败。参数分别表示表达式和测试结果。

`fail-on-check <object> <object> <object>`

　　报告预期结果不符的检查失败。参数分别表示表达式、测试结果和预期结果。

`$check <expression>...`

　　在当前环境中求值参数整体构成的表达式，求值结果不是 `#f` 则测试通过，否则调用 `fail-on-check` 。

`$check-not <expression>...`

　　在当前环境中求值参数整体构成的表达式，求值结果是 `#f` 则测试通过，否则调用 `fail-on-check` 。

`$expect <expression> <expression>...`

　　在当前环境求值第一参数和其余参数整体构成的表达式，其求值结果分别为预期结果和测试结果；以 `equal?` 比较，若结果是 `#t` 则测试通过，否则调用 `fail-on-expect` 报告错误。

`$expect-moved <expression>...`

　　在当前环境求值参数整体构成的表达式，其求值结果是测试结果；以 `moved?` 测试，若结果是 `#t` 则测试通过，否则调用 `fail-on-expect` 报告错误。

　　此外，引入以下别名：

* `check` ：同 `$check` 。
* `expect` ：同 `$expect` 。

# 初始化

　　用户程序使用的初始环境包括以下初始化：

* 确保基础环境可用，并创建以基础环境为父环境的空环境。
* 用户环境初始化，默认行为等效在当前环境中引入上层语言的库特性。

　　之后，运行用户程序。

　　实现可提供其它形式的、由实现定义的用户环境初始化操作补充或替代上述的默认用户环境初始化。

# 附录

　　本章内容是说明性的。

## 类型概要

　　本节汇总本文档定义的 Unilang 语言的语义规则中首先蕴含的可能作为被求值的结果的类型。其中，类型约束若在库的描述中出现，使用和库的描述相同的文法约定，即使未在对应的正式规则中出现。

　　除非派生实现另行指定，在程序运行中的值属于这些类型。

**注释** PTC 等要求的 `<test>` 和 `<body>` 等因仅通过约束表达式的结构进行构造得到，实际仅要求是 `<object>` 的子类型，也没有指定类型谓词，不在此视为类型约束；尽管实现仍然可以把这些表达式视为特定类型的值。

* 核心语言：
	* `<object>`
	* `<reference>`
	* 求值算法：
		* `<environment>`
		* `<list>`
		* `<symbol>`
		* `<combiner>`
		* `<operative>`
		* `<applicative>`
		* 字面量求值结果：
			* `<boolean>`
			* `<string>`
			* `<number>`
			* 单元类型：`#inert` 的类型
			* 单元类型：`#ignore` 的类型
	* **注释** 一般地，实现需要对以上类型提供对应的直接支持。
* 库：
	* `<symbols>`
	* `<eformal>`
	* `<lists>`
	* `<predicate>`
	* `<parent>`
	* 封装类型（通过 `make-encapsulation-type` 创建的和以上类型都不同的类型）

	以上类型满足以下类型包含关系：

* 任意类型都是 `<object>` 的子类型。
* 以下类型是派生类型：
	* `<combiner>` 是 `<applicative>` 和 `<operative>` 的并。
	* `<symbols>` 是 `<list>` 的子类型。
	* `<eformal>` 是 `<symbol>` 和 `#ignore` 的类型的并。
	* `<lists>` 是 `<lists>` 的子类型。
	* `<predicate>` 是 `<applicative>` 的子类型。
	* `<parent>` 是 `<environment>` 和元素限定为 `<environment>` 的 `<list>` 的并。
* 除 `<object>` 外的核心语言类型及封装类型中是非派生类型。
* 除 `<object>` 外的任意非派生类型之间两两不相交。

**注释** 关于 `<object>` 的子类型关系，另见核心语言关于类型显式要求。

