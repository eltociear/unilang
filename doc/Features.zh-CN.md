# 概述

　　作为[《Unilang 介绍》](Introduction.zh-CN.md)的补充，本文档汇总 Unilang 的语言设计中已被 Unilang 解释器实现的功能特性。

　　除另行指定的部分，本文档中的以下功能特性已在当前版本中完成支持，并继续在新的迭代版本中完善。

## 特性分类

　　本文档中，按 Unilang 语言规范，语言特性分为核心语言特性和（标准）库特性两类。

　　核心语言特性的设计相对稳定，其实现的改动需改动解释器实现支持。

　　库特性可被解释器或外部加载 Unilang 代码并求值实现。大部分特性以库特性提供。本文档不区分其实现方式。

# 核心语言特性

　　Unilang 具有较少但通用的核心语言特性，以使核心语言的功能更紧凑，语言规则更简单。这可减少扩展语言时需要注意的特例。

## 词法

　　Unilang 是自由形式的语言，不依赖缩进，其语法分析较为简单，词法分析的规则也比较简单。这主要包含从源代码中提取以空白符和括号、逗号以及分号分隔的记号。以下代码不是单独的记号：

* `(X Y)`
* `123 456`

　　提取空白符分隔后的结果对应为：

* `(` `X` `Y` `)`
* `123` `456`

## 表达式

　　表达式是语法中的基本构造。表达式通过记号组成，被递归的语法规则约束，可包含子表达式。记号构成不含其它表达式作为子表达式的简单的表达式。复合表达式以 `(` 和 `)` 作为边界，包含其它表达式作为其子表达式。

　　一些表达式的例子：

* `()` 空列表。
* `"hello"` 字符串字面量。
* `(x y)` 包含两个子表达式 `x` 和 `y` 的列表表达式。

## 中缀变换

　　表达式中允许出现中缀 `,` 和 `;` 标点。这些标点在表达式求值前会被替换，如：

* `A; B` => `$sequence A B`
* `A, B` => `list% A B`

　　变换得到前缀形式后，按剩余求值规则求值表达式，前缀的 `$sequence` 和 `list%` 在此仅作为示意。分号和逗号分别表示顺序求值子表达式和无序求值子表达式。

　　以 `;` 结尾的表达式称为语句。

## 变量

　　变量是以标识符作为名称指称的实体。标识符是可打印字符的序列，不以数字起始。

　　Unilang 变量名的标识符不受保留字或关键字的拼写限制，但 `#` 起始的记号按约定保留为字面量，通常避免作为变量名。变量名在确定的词法作用域中有效。

　　变量名可直接作为表达式，其求值的作用见以下求值算法的描述。

　　以下标识符是一些合法变量名的举例：

* `x`
* `xY`
* `FOO`
* `Bar123`
* `__LINE__`
* `*STDIN*`
* `<unknown>`
* `var-name`
* `call/cc`
* `a+b`

## 函数

　　函数是求值为合并子类型的值。函数可以是符号，符号作为变量名即为函数名。从语法上看，函数和其它表达式并没有必然区别，其含义取决于上下文中如何引入表达式。例如，以下表达式可以是函数也可以不是函数：

* `f`
* `(id f)`

## 求值算法

　　求值算法是语言设计中最整体的特性，用于决定表达式如何被处理以表达计算。一般地，求值表达式的作用包含确定表达式的值以及副作用。

　　以下是一些表达式求值的例子：

* `()` 求值后得到自身。
* `"hello"` 求值后得到自身。
* `x` 求值后得到变量 `x` 的值。
* `f x` 应用函数 `f` 到操作数 `x` 求值得到的值。
* `++ "hello, " "world"` 应用函数 `++` 到操作数 `"hello, "` 和 `"world"` 求值得到的值。
* `f ()` 应用函数 `f` 到操作数 `()` 。
* `() f x y` 求值同 `f x y` 。
* `() f` 应用函数 `f` ，函数应用没有操作数。

　　Unilang 基础语言不提供单独的注释功能。一般以字符串字面量单独构成的语句表示注释。因为求值这样的语句中的表达式没有其它作用，通常它不影响程序的语义，但在源代码中可被分析。

　　变量名在求值前具有符号类型。一般地，求值符号表达式确定符号指称的实体对应的值，这个值就是表达式求值得到的值。

　　函数应用的求值蕴含函数调用。

## 函数调用

　　函数调用是组合函数和函数的实际参数的计算过程。

　　函数调用在函数应用或其它特定的互操作（调用 C++ API ）时发生。

　　被调用的函数中，合并子可以是操作子，调用时操作数不经求值即构成函数的实际参数。合并子也可以是应用子，其调用首先求值函数的操作数，其求值结果作为实际参数，再以底层合并子作为函数继续调用。

　　应用子和其它语言中常见的函数类似。操作子类似一些语言的宏，但和应用子一样可以作为一等对象。通常建议使用应用子可满足需求时，不使用操作子。操作子对应的函数名习惯用 `$` 前缀和应用子区分，如：

* `$quote x`
* `id x`

　　函数可具有形式参数。调用时，实际参数初始化形式参数，这可能包含参数的复制。这些规则和 C++ 等语言类似。

## 一等环境

　　表达式求值时，符号作为名称被解析。判定是否存在可解析的名称依赖当前环境中的变量绑定。若以符号为键的绑定不存在，则解析失败出错，否则符号求值为绑定保存的值。

　　一个环境可具有零个或多个父环境。解析名称时从当前环境开始，深度优先递归搜索环境及其父环境，直至成功找到以名称为键的变量绑定，或无法找到绑定而失败。

　　一等环境是能作为一等对象的环境。这允许环境被以和其它对象语法上无异的方式表示，例如以下表达式的值可能表示环境：

* `e`
* `() make-environment`

　　定义变量即在环境中添加变量绑定。

## 基础环境

　　核心语言提供基础环境作为初始的当前环境的父环境。这不是一个一等环境，其中的绑定也不能被修改。

　　库特性中的变量名都在基础环境中存在绑定，因此以下库特性都是基础环境的使用的例子。

# 库特性

　　大部分 Unilang 特性以库特性提供。库提供的名称在基础环境中存在绑定。

## 内建对象

　　对象 `ignore` 的值是符号 `#ignore` ，用于需要值为 `#ignore` 同时是一等对象的场合。例如：

```
	$def! $lambda $vau (formals .body) d wrap
		(eval (cons $vau (cons formals (cons ignore body))) d);
```

　　因为 `#ignore` 不保证能作为表示变量名的符号求值，所以不能直接作为函数 `cons` 的参数。（求值 `cons #ignore body` 时会求值参数，以 `#ignore` 作为变量名进行名称解析，不符合构造一个包含 `#ignore` 值的列表的目的。）而 `ignore` 经过求值，结果是 `#ignore` 。

## 等价谓词

　　等价谓词判断两个参数之间的等价关系。库提供的等价谓词 `eq?` 和 `eqv?` ，分别表示对象同一性和（非列表）值的相等关系。例如：

```
$def! x "FOO";
$def! y "FOO";

eq? x y; "=> #f";
eqv? x y; "=> #t";
```

## 条件求值

　　函数 `$if` 提供基本分支判断和条件求值操作。条件参数被求值，`#f` 以外的结果都视为条件成立。当条件成立时，求值第二个参数，否则求值第三个参数。表达式求值的结果被求值的参数的求值的结果。第三个参数可省略，隐含为 `#inert` 。

　　例如：

```
$def! x ();
display "x is ";
display ($if (null? x) "empty" "not empty");
```

## 列表基本操作

　　函数 `null?` 判断参数值是否为空列表（即值是否等于 `()` ）。（例子参见以上 `$if` 的例子。）

　　函数 `list` 构造以参数为元素的列表对象。

　　函数 `cons` 是基本的列表构造器，使用第一个参数值和第二个列表参数值构造列表对象。新构造的对象是包含第一个参数以及第二个参数中的所有元素构成的列表，如：

　　函数 `list*` 和 `cons` 类似，但支持多个参数，其中最后一个参数要求同 `cons` 的第二个参数，之前的参数在结果中顺序连接。

```
cons "x" (); "same to: "; list "x";
cons "y" (list "a" "b"); "same to: "; list "y" "a" "b";
list* "0" "1" "2" (list "3" "4"); "same to: "; list "0" "1" "2" "3" "4";
```

## 环境和求值操作

　　函数 `get-current-environment` 取当前环境的弱引用。

　　函数 `eval` 在第二参数指定的环境中求值第一参数。

　　函数 `make-environment` 以指定参数为父环境创建环境。

　　函数 `lock-environment` 锁定环境弱引用为环境强引用。

　　函数 `lock-current-environment` 取当前环境的强引用。

　　这些操作支持一等环境和利用一等环境进行求值，能通过源程序代码改变求值的上下文。最简单的情况下，使用 `eval` 求值也可以和不使用这些操作的求值作用相同，如：

```
eval (list display "Hello, world") (() get-current-environment)
```

　　相当于：

```
display "Hello, world"
```

　　但在更一般的情况下，以一等对象作为参数的方式指定求值环境没有不使用这些操作的直接的简单对应写法。特别地，`eval` 的参数可由程序运行的逻辑确定，这不总是能直接通过源码确定来代替。

## 变量定义

　　函数 `$def!` 引入变量并指定初值。如：

```
$def! x "FOO";
```

　　变量定义支持递归的模式匹配和末尾以 `.` 起始的变量名匹配列表，及 `#ignore` 忽略不需要的参数，同时匹配多个参数及引入多个变量，如：

```
$def! ((x #ignore .y) z) list (list "X" "NOT USED" "Y1" "Y2") "Z";
```

## 变量设置

　　函数 `$set!` 在指定环境中定义变量。简单情形下，可以类似 `$def!` ：

```
$set! (() get-current-environment) x "FOO";
```

　　相当于：

```
$def! x "FOO";
```

## 合并子操作

　　函数 `$vau/e` 和 `$vau` 用来构造操作子，如：

```
$def! $f $vau/e (() get-current-environment) (body) d eval body d;
$def! $f2 $vau (body) d eval body d;
```

　　其中形式参数支持类似变量定义的模式匹配，实际上是形式参数树而不只是参数列表。

　　`$vau/e` 支持显式指定静态环境，而 `$vau` 隐含静态环境为求值 `$vau` 表达式时的当前环境。静态环境被用于作为调用被构造的合并子在调用时的环境的父环境。在创建合并子时指定静态环境，允许静态环境是强引用，在环境的绑定中保存对象，而使构造的合并子对这些对象具有间接的所有权。

　　定义操作子时同时允许可选地引入动态环境变量（若不需要，可以是 `#ignore` ）。动态环境是调用合并子时的当前环境。

　　函数 `wrap` 包装合并子为应用子。对应地，操作子 `unwrap` 取应用子的底层合并子。

　　函数 `$lambda` 构造应用子，如：

```
$def! id $lambda (x) x;
```

　　函数 `$lambda` 支持和 `$vau` 相同的形式参数树语法，但不支持指定静态和动态环境（分别隐含为 `() get-current-environment` 和 `#ignore` ）。

　　作为 `$vau` 和 `wrap` 等函数的例子，`$lambda` 自身可用以上操作实现：

```
$def! $lambda $vau (formals .body) d wrap
	(eval (cons $vau (cons formals (cons ignore body))) d);
```

## 合并子定义

　　许多时候需要定义单个合并子变量而不需要 `$def!` 同时定义多个变量。库提供语法糖满足这个需求，如

```
$defl! id (x) x;
```

　　相当于：

```
$def! id $lambda (x) x;
```

　　类似地，也有 `$defv!` 。此外，`$defw!` 类似 `$defl!` ，但允许指定动态环境。

## 封装类型

　　函数 `make-encapsulation-type` 创建和之前的对象类型都不同的值的构造器、类型判断谓词和访问器，如：

```
$def! (e p? d) () make-encapsulation-type;
$def! x e (list ());
p? x; "=> #t";
p? (list ()); "=> #f";
d x; "=> (())";
```

## 标准环境

　　函数 `make-standard-environment` 创建和初始环境类似的以基础环境为父环境的环境：

```
$def! base-env () make-standard-environment;
```

## 顺序求值

　　函数 `$sequence` 顺序求值参数。结果为最后一个求值的参数，或 `#inert` （如不存在参数）。这和 `;` 语法经过中缀变换后的功能实质相同，主要用于确保含副作用的表达式求值的顺序：

```
$sequence (display "x") (display "y");
```

## 列表访问

　　函数 `first` 和 `rest%` 接受一个应为非空列表的参数，分别取列表的第一个元素和剩余元素：

```
$def! li list "a" "b" "c";
first li; "same to: "; "a";
rest% li; "same to: "; list "b" "c";
```

## 列表函数应用

　　函数 `apply` 以列表元素作为参数，在指定环境中应用一个应用子，如：

```
apply foo (list "x" "y") e
```

　　相当于：

```
eval (list () foo "x" "y") e
```

　　环境参数可省略。若不指定环境参数，则隐含为 `() make-environment` 。

## 派生条件求值

　　函数 `$cond` 按分支顺序求值条件，并求值第一个成立的条件对应的表达式，如：

```
$cond x
	((eqv? x "a") "x is a")
	((eqv? x "b") "x is b")
	((eqv? x "c") "x is c")
	(#t "unknown");
```

　　函数 `$when` 类似 `$if` ，但只指定条件成立的分支，且隐含顺序求值子表达式，如：

```
$when (eqv? x "a") (display "x") (display " is a");
```

　　函数 `$unless` 类似 `$when` ，但条件取反，如：

```
$unless (eqv? x "a") (display "x") (display " is not a");
```

## 逻辑操作

　　一元函数 `not?` 表示逻辑非运算。

　　函数 `$and?` 和 `$or?` 表示逻辑与和逻辑或运算。两者都支持短路求值。表达式的是求值结束时最后一个子表达式的值（若存在），或默认值（对 `$and?` 为 `#t` ，对 `$or?` 为 `#f` 。）  

　　例如：

```
not? #t; "=> #f";
not? "x"; "=> #f";
not? #f; "=> #t";
$and? (eqv? "x" "x") () "z"; "=> "z";
$or? #f (eqv? "x" "y"); "=> #f";
```

## 列表算法

　　函数 `accr`、 `foldr` 和 `map1` 对列表元素应用。如：

```
$import! std.strings ++;
map1 ($lambda (x) ++ x "s") (list "a" "b" "c"); "=> (as bs cs)";
```

　　函数 `map1` 的 `1` 表示接受的应用子具有一个参数。相对 `map1` ，`accr` 和 `foldr1` 提供更多的参数，允许更底层的定制功能。

## 局部作用域

　　函数 `$let` 提供词法局部作用域，如：

```
$import! std.strings ++;
$let ((x "a") (y "b"))
	++ x y;
```

　　以上示例的结果是字符串 `"ab"` 。

　　同合并子调用一样，求值 `$let` 内部的表达式时，使用新创建的环境。在 `$let` 中声明的局部对象在外部不会自动可用而影响外部环境。

　　函数 `$let/d` 与 `$let` 类似，但允许指定绑定动态环境的变量，以便在 `$let/d` 内部访问 `$let/d` 的外部环境（注意这个环境不是求值 `$let/d` 内部表达式的当前环境）。函数 `$let*` 可视为嵌套的 `$let` ，保证定义局部对象的顺序。而 `$letrec` 则允许递归定义：初始化局部变量的表达式可以引用之后定义的局部变量。

## 绑定到环境转换

　　函数 `$bindings->environment` 转换 `$let` 语法相同的局部对象定义为环境，如：

```
$def! new-env $bindings->environment (x "x") (y "y");
```

　　这是一个创建环境的简便方法。创建的环境不具有父环境。

　　类似地，函数 `$bindings->environment` 也能转换绑定得到环境，但同时支持显式指定父环境。

## 其它环境操作

　　函数 `$provide` 创建环境作为结果，并在动态环境中求值表达式定义变量。这适合模块化地提供变量，如：

```
$def! my-module $provide! (exported-symbol-x exported-symbol-y)
(
	$import! std.strings ++;
	$def! internal-symbol "FOO";
	$def! exported-symbol-x internal-symbol;
	$def! exported-symbol-y ++ internal-symbol "BAR";
);
```

　　函数 `$provide/d!` 和 `$provide!` 类似，但允许指定绑定动态环境的变量。

　　函数 `$import!` 从参数指定的环境中引入变量定义到当前环境。这可用于模块化的导入，如：

```
$import! my-module exported-symbol-x;
```

## 加载外部翻译单元

　　函数 `load` 以参数指定路径的文件作为 Unilang 基础语言源文件，在当前环境中加载并求值，如：

```
load "external.txt"
```

## 标准输出

　　函数 `display` 在标准输出中输出参数的人类可读的外部表示，如：

```
display "FOO";
```

　　函数 `newline` 在标准输出中输出换行，调用方式为：

```
() newline;
```

